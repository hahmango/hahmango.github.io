<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020 Wuhan University Collegiate Programming Contest (Preliminary Contest)--A Monument For Heroes</title>
    <url>/2020/04/13/2020-Wuhan-University-Collegiate-Programming-Contest-Preliminary-Contest-A-Monument-For-Heroes/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5166/A" target="_blank" rel="noopener">A Monument For Heroes</a></p>
<h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>Months ago, the COVID-19 swept Wuhan. In order to control the outbreak, many people tried their best to help Wuhan, and with their help, we finally (almost) beat the virus, so we are going to set up a monument and write the names of all the contributors to express our gratitude to them. But there are so many people who have helped Wuhan so there are so many names to write, and how to arrange them is a big problem, so we decided that we will choose some representative names and rearrange their order to make them neatly. But until now we still do not know the maximum length of letters that will be write on the monument. We cannot leave enough space for these names without this number, so we leave this problem for you. <a id="more"></a></p>
<p>Now you will be given the name of all the contributors, and you can choose some and connect them in a certain order to make them neat. A permutation of names is neat only when for every component except the last one, the last letter of the component is the same as the first letter of the next component, and the last letter of the whole name is the same as the first one. E.g. if there are 3 contributors called ”abc”, “fga”, “cdef”, we can choose all these three names and combine them to “abccdeffga” to write on the monument with length of 10. </p>
<p>What’s more, these contributors agreed that one who contributed more is more important. They will provide you a preference list according to their agreement and you should connect the permutation <strong>strictly</strong> according to the list. That is, if a name $s$ appears earlier than name $t$ in the preference list, ss would also appear earlier than tt if they are both selected into the permutations. </p>
<p>There will be many permutations which are neat, but we should leave enough space for every possible one, so can you tell us the length of the longest one? </p>
<p>Note: there might be multiple contributors have the same name.</p>
<h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h4><p>The first line contains integer $(1 ≤ n ≤ 2*10^5)$ — the number of contributors. Next $n$ lines contain $n$ names, one per line. A contributor’s name is a non-empty sequence of lowercase Latin letters. Its length does not exceed $10$ characters.</p>
<p>Meanwhile, this is a preference list, the name comes earlier should also appear earlier in your final permutation.</p>
<h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h4><p>Print a single number – the maximum length of combination of names. If there are no possible permutations, print $0$ instead.</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>输入</p>
<blockquote>
<p>3<br>abc<br>ca<br>cba </p>
</blockquote>
<p>输出</p>
<blockquote>
<p>6</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目是从给定一个字符串序列中，找出能连接的最长的序列长度，其中的每个字符串的相互顺序不能变。注意还需要保证最后形成的子序列的首尾是相同的字符。</p>
<p>在读取字符串的时候，直接进行处理，将首字母、尾字母和长度记录下来，便于后面处理。</p>
<p>由于是通过字符来连接，那么就可以使用遍历所有字符串，每次循环遍历所有字母的方式来 DP，每次最多只需要比较26次，将<code>d[i][j]</code>表示为以当前字符串作为起点，首字母为 $i$，遍历所有字母 $j$ 作为打算拼接的尾字母，能形成的最长的序列的长度，状态转移方程为 $d(i, j) = \{max(d(i, j), d(last_i, j)+len_i)\quad |\quad d(last_i, j)&gt;0\}$。需要保证 $d(last_i, j)&gt;0$ 才进行决策，否则就相当于和一个不存在的字符串进行了拼接。和自身字符串长度的比较要放后面，否则如果先记录当前字符串的长度，假设当前字符串首尾都是 a，当 $last_i = j = ‘a’$ 时，就会导致<code>d[a][a]</code>的长度翻倍。</p>
<p>最后遍历一遍首尾字母相同的 $d$ 值，找出最长的长度。</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">27</span>][<span class="number">27</span>], fi[maxn], la[maxn], len[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n, l, ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">12</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    l = <span class="built_in">strlen</span>(s);</span><br><span class="line">    fi[i] = s[<span class="number">0</span>]-<span class="string">'a'</span>; la[i] = s[l<span class="number">-1</span>]-<span class="string">'a'</span>; len[i] = l;</span><br><span class="line">  &#125;</span><br><span class="line">  d[fi[n]][la[n]] = len[n];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++)</span><br><span class="line">      <span class="keyword">if</span>(d[la[i]][j])</span><br><span class="line">        d[fi[i]][j] = <span class="built_in">max</span>(d[fi[i]][j], len[i] + d[la[i]][j]);</span><br><span class="line">    d[fi[i]][la[i]] = <span class="built_in">max</span>(d[fi[i]][la[i]], len[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d[i][i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>牛客竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 Wuhan University Collegiate Programming Contest (Preliminary Contest)--Best Match</title>
    <url>/2020/04/13/2020-Wuhan-University-Collegiate-Programming-Contest-Preliminary-Contest-Best-Match/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5166/B" target="_blank" rel="noopener">Best Match</a></p>
<h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>There is a traditional activity held by school of computer science in WuHan University: Five-day lovers. But this year, due to COVID-19, this event has to be held online and <strong>HamsterW</strong> wants to organize this activity to help schoolmates who have no girlfriend or boyfriend. <a id="more"></a></p>
<p><strong>HamsterW</strong> knows a lot about opposites attract theory. That is the key principle of this Five-day lovers. The Five-day lovers activity has classified each registered schoolmates according his/her interests and assigned to the $i-th$ schoolmate number $t_i(-20 \leq t_i \leq 20)$ . A number will be assigned randomly to any schoolmates.</p>
<p><strong>HamsterW</strong> wants to advertise this activity and inform the number of opposite matches, that is, matches who have opposite values of $t$. There are two schoolmates in a match. The schoolmate can join multiple groups at the same time.</p>
<p>For example, if $t=(1, -1, 1, -1)$, then any two elements $t_i$ and $t_j$ form a match if $i≠j$. Consequently, in this case the result is equal to 4. Of course, a schoolmate can’t date with him/herself.</p>
<p>Help <strong>HamsterW</strong> and write the program that will find the result by the given sequence $t_1,t_2,…,t_n$. Maybe one of you will be in these matched cases.</p>
<h4 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h4><p>The first line of the input data contains an integer $n \quad (1 \leq n \leq 5*10^5)$ which represents the number of registered schoolmates of the Five-day lovers.<br>The second line contains a sequence of integers $t_1,t_2,…,t_n(-20 \leq t_i \leq 20)$, $t_i$ is the parameter of the $i-th$ schoolmate that has been assigned to the schoolmate by the result of the analysis of his interests.</p>
<h4 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h4><p>Print the number of matches of schoolmates with opposite $t$. The opposite number for $x$ is number $−x$ ( 0 is opposite to itself ).</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目是求配对的数量，直接用桶存储所有数，求所有数的正数和负数的乘积相加，再加上 0 的 $n$ 项等差数列的累加和即可。注意要<code>long long</code>。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">21</span>], zn, q[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n, c;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">    <span class="keyword">if</span>(c &gt; <span class="number">0</span>) q[c]++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c &lt; <span class="number">0</span>) p[-c]++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ans += zn;</span><br><span class="line">      zn++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">20</span>; i++)</span><br><span class="line">    ans += p[i] * q[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>牛客竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 Wuhan University Collegiate Programming Contest (Preliminary Contest)--DIY Masks at Home</title>
    <url>/2020/04/13/2020-Wuhan-University-Collegiate-Programming-Contest-Preliminary-Contest-DIY-Masks-at-Home/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5166/D" target="_blank" rel="noopener">DIY Masks at Home</a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题意是给你一个由大写字母构成的二维矩阵，你需要找到一个最大的正方形，使得这个正方形内只包含一种字母。<a id="more"></a></p>
<p>有两种方法：</p>
<ol>
<li><p>一种是直接 DP，遍历每一个块，用<code>d[i][j]</code>表示以 $(i, j)$ 为右下角坐标，能行成的最大的正方形的边长是多少。<strong>状态转移</strong>方程为 $d(i, j) = min(d(i-1, j-1), min(d(i-1, j), d(i, j-1)))$，每一次都与 $(i-1,j-1),(i-1,j),(i,j-1)$ 三个点判断是否能形成同一个颜色正方形。注意也需要对 $d(i-1, j-1)$ 进行决策，因为会有这种情况：$(i, j)$ 这个方块的左边和上面都是两个正方形，而 $(i-1, j-1)$ 只是这两个正方形的交点，所以他会影响<code>d[i][j]</code>的大小。<br>时间复杂度：$O(nm)$</p>
</li>
<li><p>另一种方法是用二分，每次去找当前划分后的矩阵是否是同一个颜色的正方形，找不到的话继续划分，找到了直接跳出。<br>时间复杂度：$O(nmlog(n))$</p>
</li>
</ol>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> g[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> T, n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, g[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">        d[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(g[i<span class="number">-1</span>][j<span class="number">-1</span>]==g[i][j] &amp;&amp; g[i<span class="number">-1</span>][j]==g[i][j] &amp;&amp; g[i][j<span class="number">-1</span>]==g[i][j])</span><br><span class="line">          d[i][j] = <span class="built_in">min</span>(d[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(d[i<span class="number">-1</span>][j], d[i][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, d[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>牛客竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 Wuhan University Collegiate Programming Contest (Preliminary Contest)--E Yu is a Brutal Creature</title>
    <url>/2020/04/13/2020-Wuhan-University-Collegiate-Programming-Contest-Preliminary-Contest-E-Yu-is-a-Brutal-Creature/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5166/E" target="_blank" rel="noopener">E Yu is a Brutal Creature</a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题意是找出 0 到 n 之间所有满足 $\frac{n^2+1}{n+1}$ 为整数的数的个数。由于</p>
<script type="math/tex; mode=display">
\frac{n^2+1}{n+1}=\frac{n^2+n}{n+1}-\frac{n-1}{n+1}=n-\frac{n-1}{n+1}</script><p>显然，只有当 $n=0$ 或 $1$ 的时候，式子才会是整数，所以答案是 $n-1$。<a id="more"></a></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> T, n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>牛客竞赛</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>uva11400 Lighting System Design 线性结构DP</title>
    <url>/2020/04/05/uva11400-Lighting-System-Design-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84DP/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-11400" target="_blank" rel="noopener">uva11400 Lighting System Design</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>You are given the task to design a lighting system for a huge conference hall. After doing a lot of calculation and sketching, you have figured out the requirements for an energy-efficient design that can properly illuminate the entire hall. According to your design, you need lamps of n different power ratings. For some strange current regulation method, all the lamps need to be fed with the same amount of current. So, each category of lamp has a corresponding voltage rating.<a id="more"></a> Now, you know the number of lamps and cost of every single unit of lamp for each category. But the problem is, you are to buy equivalent voltage sources for all the lamp categories. You can buy a single voltage source for each category (Each source is capable of supplying to infinite number of lamps of its voltage rating.) and complete the design. But the accounts section of your company soon figures out that they might be able to reduce the total system cost by eliminating some of the voltage sources and replacing the lamps of that category with higher rating lamps. Certainly you can never replace a lamp by a lower rating lamp as some portion of the hall might not be illuminated then. You are more concerned about money-saving than energy-saving. Find the minimum possible cost to design the system.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>Each case in the input begins with n (1 ≤ n ≤ 1000), denoting the number of categories. Each of the following n lines describes a category. A category is described by 4 integers - V (1 ≤ V ≤ 132000), the voltage rating, K (1 ≤ K ≤ 1000), the cost of a voltage source of this rating, C (1 ≤ C ≤ 10), the cost of a lamp of this rating and L (1 ≤ L ≤ 100), the number of lamps required in this category. The input terminates with a test case where n = 0. This case should not be processed.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print the minimum possible cost to design the system.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>有一个照明系统需要用到n种灯，每种灯的电压为V，电源费用K，每个灯泡费用为C，需要该灯的数量为L。注意到，电压相同的灯泡只需要共享一个对应的电源即可，还有电压低的灯泡可以被电压高的灯泡替代。为了节约成本，你将设计一种系统，使之最便宜。</p>
<p>意思是这 n 种灯已经模拟了可以使用并且打算被安装，但是可以想办法节约成本。</p>
<p>由于只能是电压低的灯泡被电压高的灯泡替换，所以先按电压进行排序。<br>在替换的时候，对于某一种灯泡，显然是要么不换，要么全替换。（如果能替换一部分，那么说明替换的灯泡成本更低，那么肯定是全部替换）</p>
<p>这属于线性结构上的 DP，直接使用$i$来表示<strong>状态</strong>即可。<br>设s[i]为前i种灯泡的总数量(即L值之和)，<code>d[i]</code>以<code>i</code>为终点，表示为灯泡<code>1~i</code>的最小开销，则<strong>状态转移方程</strong>为<code>d[i] = min(d[i], d[j] + (s[i]-s[j])*c[i] + k[i]))</code>，表示前$j$个先用最优方案买，然后<code>j+1~i</code>个都用第$i$号的电源。答案为<code>d[n]</code>。</p>
<p>不能用外层循环只去替换内层的当前那种灯泡，假如用当前这个$i$替换掉了一个$j$的灯泡，这样就错了，前面的灯泡可能用的是他的电源，而你无法修改<code>d[j]</code>本身的值。</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lamp</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, k, c, l;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> lamp &amp;r) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; r.v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn], s[maxn]; <span class="comment">// d[i] 为灯泡 1~i 的最小开销；s[i] 为前 i 种灯泡的总个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    lamp &amp;u = a[i];</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] + u.l;</span><br><span class="line">    d[i] = s[i]*u.c + u.k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)</span><br><span class="line">      d[i] = <span class="built_in">min</span>(d[i], d[j] + (s[i]-s[j])*u.c + u.k); <span class="comment">// 表示之前j个先按j的最优方案买，然后之后的 j+1~i 都用 i 的灯泡</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n, v, k, c, l;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">      lamp &amp;u = a[i];</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u.v, &amp;u.k, &amp;u.c, &amp;u.l);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">    dp(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[n]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DP</category>
        <category>线性结构上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>uva</tag>
      </tags>
  </entry>
  <entry>
    <title>第十一届 2020年 蓝桥杯省赛模拟</title>
    <url>/2020/04/18/2020%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>这是第十一届蓝桥杯省模拟赛的试题和题解，C++组的，前四个是填空题，有点奇葩，后六个大题，难度总的来说还好，个人觉得倒数第二题比较难，看来还得多练啊。<a id="more"></a></p>
<h3 id="算字节"><a href="#算字节" class="headerlink" title="算字节"></a>算字节</h3><p>问题描述<br>　　在计算机存储中，12.5MB是多少字节？</p>
<p>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p>
<blockquote>
<p>答案为 $12.5 \ast 1024 \ast 1024=13107200$</p>
</blockquote>
<p><del>话说怎么又出了这种题</del></p>
<hr>
<h3 id="括号序列"><a href="#括号序列" class="headerlink" title="括号序列"></a>括号序列</h3><p>问题描述<br>　　由1对括号，可以组成一种合法括号序列：<code>()</code>。<br>　　由2对括号，可以组成两种合法括号序列：<code>()()、(())</code>。<br>　　由4对括号组成的合法括号序列一共有多少种？</p>
<p>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p>
<blockquote>
<p>4对括号组成的合法括号序列有：<br>1层：<code>()()()(): 1</code><br>2层：<code>(())()(): 3, (())(()): 1, (()())(): 2, (()()()): 1</code><br>3层：<code>((())()): 2, ((()())): 1, ((()))(): 2</code><br>4层：<code>(((()))): 1</code><br>所以一共是<code>14</code>种</p>
</blockquote>
<hr>
<h3 id="边数"><a href="#边数" class="headerlink" title="边数"></a>边数</h3><p>问题描述<br>　　一个包含有2019个结点的无向连通图，最少包含多少条边？</p>
<p>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p>
<blockquote>
<p><code>n</code> 个结点的无向连通图，最少有<code>n-1</code>条边，再少就不连通了<br>答案为<code>2018</code></p>
</blockquote>
<hr>
<h3 id="字母排列"><a href="#字母排列" class="headerlink" title="字母排列"></a>字母排列</h3><p>问题描述<br>　　将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。<br>　　请问，总共能排列如多少个不同的单词。</p>
<p>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p>
<blockquote>
<p>7个字母求排列：$A_7^7$<br>由于有两个字母相同，所以要除以 $A_2^2$<br>答案为：$\frac{A_7^7}{A_2^2}=2520$</p>
</blockquote>
<hr>
<h3 id="反倍数"><a href="#反倍数" class="headerlink" title="反倍数"></a>反倍数</h3><p>问题描述<br>　　给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。<br>　　请问在 1 至 n 中有多少个反倍数。</p>
<p>输入格式<br>　　输入的第一行包含一个整数 n。<br>　　第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。</p>
<p>输出格式<br>　　输出一行包含一个整数，表示答案。</p>
<p>样例输入<br>30<br>2 3 6</p>
<p>样例输出<br>10</p>
<p>样例说明<br>　　以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。</p>
<p>评测用例规模与约定<br>　　对于 40% 的评测用例，1 &lt;= n &lt;= 10000。<br>　　对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000000，1 &lt;= a &lt;= n，1 &lt;= b &lt;= n，1 &lt;= c &lt;= n。</p>
<p>直接全部遍历一遍，每个数都对 a, b, c 分别求余，能整除就不要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, a, b, c, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;c);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(i%a &amp;&amp; i%b &amp;&amp; i%c) ans++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p>问题描述<br>　　给定一个单词，请使用凯撒密码将这个单词加密。<br>　　凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，…，w变为z，x变为a，y变为b，z变为c。<br>　　例如，lanqiao会变成odqtldr。</p>
<p>输入格式<br>　　输入一行，包含一个单词，单词中只包含小写英文字母。</p>
<p>输出格式<br>　　输出一行，表示加密后的密文。</p>
<p>样例输入<br>lanqiao</p>
<p>样例输出<br>odqtldr</p>
<p>评测用例规模与约定<br>　　对于所有评测用例，单词中的字母个数不超过100。</p>
<p>先让每个字母变成整数，再<code>+3</code>然后对 26 取模就行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[maxn];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    c = (<span class="keyword">char</span>)(s[i]-<span class="string">'a'</span>+<span class="number">3</span>)%<span class="number">26</span>+<span class="string">'a'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="蛇形填数"><a href="#蛇形填数" class="headerlink" title="蛇形填数"></a>蛇形填数</h3><p>问题描述<br>　　对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。<br>　　例如，一个 4 行 5 列的螺旋矩阵如下：<br>　　1 2 3 4 5<br>　　14 15 16 17 6<br>　　13 20 19 18 7<br>　　12 11 10 9 8</p>
<p>输入格式<br>　　输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。<br>　　第二行包含两个整数 r, c，表示要求的行号和列号。</p>
<p>输出格式<br>　　输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。</p>
<p>样例输入<br>4 5<br>2 2</p>
<p>样例输出<br>15</p>
<p>评测用例规模与约定<br>　　对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。<br>　　对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。<br>　　对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= r &lt;= n，1 &lt;= c &lt;= m。</p>
<p>循环填数，每次循环填一圈数。一共 $n*m$ 个数，填满就跳出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, r, c, x, y, cnt, tn;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;r, &amp;c);</span><br><span class="line">  tn = n * m;</span><br><span class="line">  cnt = a[x=<span class="number">0</span>][y=<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(cnt &lt; tn) &#123;</span><br><span class="line">    <span class="keyword">while</span>(y+<span class="number">1</span> &lt; m &amp;&amp; !a[x][y+<span class="number">1</span>]) a[x][++y] = ++cnt;</span><br><span class="line">    <span class="keyword">while</span>(x+<span class="number">1</span> &lt; n &amp;&amp; !a[x+<span class="number">1</span>][y]) a[++x][y] = ++cnt;</span><br><span class="line">    <span class="keyword">while</span>(y<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; !a[x][y<span class="number">-1</span>]) a[x][--y] = ++cnt;</span><br><span class="line">    <span class="keyword">while</span>(x<span class="number">-1</span> &gt;=<span class="number">0</span> &amp;&amp; !a[x<span class="number">-1</span>][y]) a[--x][y] = ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[r<span class="number">-1</span>][c<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="摆动序列-DP"><a href="#摆动序列-DP" class="headerlink" title="摆动序列 DP"></a>摆动序列 DP</h3><p>问题描述<br>　　如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 $a[2i]<a[2i-1]$, $a[2i+1]>a[2i]$。<br>　　小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。</p>
<p>输入格式<br>　　输入一行包含两个整数 m，n。</p>
<p>输出格式<br>　　输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。</p>
<p>样例输入<br>3 4</p>
<p>样例输出<br>14</p>
<p>样例说明<br>　　以下是符合要求的摆动序列：<br>　　2 1 2<br>　　2 1 3<br>　　2 1 4<br>　　3 1 2<br>　　3 1 3<br>　　3 1 4<br>　　3 2 3<br>　　3 2 4<br>　　4 1 2<br>　　4 1 3<br>　　4 1 4<br>　　4 2 3<br>　　4 2 4<br>　　4 3 4</p>
<p>评测用例规模与约定<br>　　对于 20% 的评测用例，1 &lt;= n, m &lt;= 5；<br>　　对于 50% 的评测用例，1 &lt;= n, m &lt;= 10；<br>　　对于 80% 的评测用例，1 &lt;= n, m &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n, m &lt;= 1000。</p>
<p>一道<code>DP</code>题，外圈循环依次遍历<code>m</code>个位置，内圈循环对当前位置尝试填<code>n</code>个数。<strong><code>d[i][j]</code></strong>表示当前第<code>i</code>个位置放<code>j</code>，整个<code>1~i</code>的所有序列共有多少种选择。这里需要分情况，如果当前位置是奇数，则他需要比前一个数大，如果当前位置放<code>j</code>的话，则前一个位置上的数为<code>1~j-1</code>的都满足，而当前位置放<code>j-1</code>的所有序列肯定也被放<code>j</code>的包含，所以奇数位置时，正序填数，<strong>状态转移</strong>方程为<code>d[i][j] = (d[i-1][j-1] + d[i][j-1])</code>。偶数位置也同理，偶数位就逆序填数，<strong>状态转移</strong>方程为<code>d[i][j] = (d[i-1][j+1] + d[i][j+1])</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn]; <span class="comment">// d[i][j] 表示第 i 个位置放 j，整个 1~i 的序列共有多少种选择</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m, n, ans=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) d[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;=n; j++) d[i][j] = (d[i<span class="number">-1</span>][j<span class="number">-1</span>] + d[i][j<span class="number">-1</span>]) % <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;=<span class="number">1</span>; j--) d[i][j] = (d[i<span class="number">-1</span>][j+<span class="number">1</span>] + d[i][j+<span class="number">1</span>]) % <span class="number">10000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) ans = (ans + d[m][j]) % <span class="number">10000</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="植树"><a href="#植树" class="headerlink" title="植树"></a>植树</h3><p>问题描述<br>　　小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。<br>　　小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。<br>　　然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。<br>　　他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。<br>　　小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。</p>
<p>输入格式<br>　　输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。<br>　　接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。</p>
<p>输出格式<br>　　输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。</p>
<p>样例输入<br>6<br>1 1 2<br>1 4 2<br>1 7 2<br>4 1 2<br>4 4 2<br>4 7 2</p>
<p>样例输出<br>12</p>
<p>评测用例规模与约定<br>　　对于 30% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 20；<br>　　对于所有评测用例，1 &lt;= n &lt;= 30，0 &lt;= x, y &lt;= 1000，1 &lt;= r &lt;= 1000。</p>
<p>这题实在没什么思路，用 DFS 暴力搜的。尽管靠能冲突能剪枝，但是还是指数级的，$O(n)=2^n$，之后会了再进行改进。<br>这里我先预处理冲突，将所有冲突计算出来，之后就可以不用每次重复计算，直接判断即可。DFS 的搜索树是 $n$ 层的二叉树，每次决策种这棵树和不种这棵树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], r[maxn], ar[maxn], n, d[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> conflict[maxn][maxn], a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isconflict</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((x[u]-x[v])*(x[u]-x[v]) + (y[u]-y[v])*(y[u]-y[v])) &lt; r[u]+r[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inline void see() &#123;for(int i=1; i&lt;=n; i++) if(a[i])printf(" %d", i); printf("\n");&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(u == n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> ans = dfs(u+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;u; i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i] &amp;&amp; conflict[i][u]) <span class="keyword">return</span> ans;</span><br><span class="line">  a[u] = <span class="number">1</span>;</span><br><span class="line">  ans = <span class="built_in">max</span>(ans, dfs(u+<span class="number">1</span>) + ar[u]);</span><br><span class="line">  a[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x[i], &amp;y[i], &amp;r[i]);</span><br><span class="line">    ar[i] = r[i] * r[i]; <span class="comment">// 计算面积</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 预先计算冲突</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      <span class="keyword">if</span>(isconflict(i, j)) conflict[i][j] = conflict[j][i] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, dfs(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="村庄通电-Kruskal-并查集"><a href="#村庄通电-Kruskal-并查集" class="headerlink" title="村庄通电 Kruskal+并查集"></a>村庄通电 Kruskal+并查集</h3><p>问题描述<br>　　2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。<br>　　这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。<br>　　现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。<br>　　小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 (x_1, y_1) 高度为 h_1 的村庄与坐标为 (x_2, y_2) 高度为 h_2 的村庄之间连接的费用为<br>　　$\sqrt{((x_1-x_2)<em>(x_1-x_2)+(y_1-y_2)</em>(y_1-y_2))}+(h_1-h_2)*(h_1-h_2)$。<br>　　在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。<br>　　由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。</p>
<p>输入格式<br>　　输入的第一行包含一个整数 n ，表示村庄的数量。<br>　　接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。</p>
<p>输出格式<br>　　输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。</p>
<p>样例输入<br>4<br>1 1 3<br>9 9 7<br>8 8 6<br>4 5 4</p>
<p>样例输出<br>17.41</p>
<p>评测用例规模与约定<br>　　对于 30% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000，0 &lt;= x, y, h &lt;= 10000。</p>
<p>这题算是比较标准的最小生成树模板题，我这里采用的是 Kruskal，首先读入<code>n</code>个村庄，然后生成 他们每两点之间的边，放到优先队列里进行堆排。然后进行 Kruskal 算法，每次取最小的边加入结果集中，如果加入的边会导致产生环，则不加入，就是说加入的边的两个点必须属于两个不同的连通分量，如果他们已经在同一个连通分量中，则再加入必然会导致产生环。这里使用了并查集来优化连通分量的查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">double</span> w;</span><br><span class="line">  node(<span class="keyword">int</span> u=<span class="number">0</span>, <span class="keyword">int</span> v=<span class="number">0</span>, <span class="keyword">double</span> w=<span class="number">0</span>) : u(u), v(v), w(w) &#123;&#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;r) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> w &gt; r.w;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], h[maxn], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x[i], &amp;y[i], &amp;h[i]);</span><br><span class="line">  priority_queue&lt;node&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 将边从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      q.push(node(i, j, <span class="built_in">sqrt</span>((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])) + (h[i]-h[j])*(h[i]-h[j])));</span><br><span class="line">  <span class="comment">// Kruskal</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) p[i] = i; <span class="comment">// 初始化并查集</span></span><br><span class="line">  node u;</span><br><span class="line">  <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    u = q.top(); q.pop();</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">find</span>(u.u), y=<span class="built_in">find</span>(u.v); <span class="comment">// 找两点各自所在的连通分量</span></span><br><span class="line">    <span class="keyword">if</span>(x != y) &#123;ans += u.w; p[x] = y;&#125; <span class="comment">// 若不在同一个连通分量，则合并连通分量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.2f"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>蓝桥杯</tag>
        <tag>Kruskal</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>uva11584 Partitioning by Palindromes 线性结构DP</title>
    <url>/2020/04/06/uva11584-Partitioning-by-Palindromes-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84DP/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-11584" target="_blank" rel="noopener">uva11584 Partitioning by Palindromes</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>We say a sequence of char- acters is a palindrome if it is the same written forwards and backwards. For example, ‘racecar’ is a palindrome, but ‘fastcar’ is not.<br>A partition of a sequence of characters is a list of one or more disjoint non-empty groups of consecutive characters whose concatenation yields the initial sequence. For example, (‘race’, ‘car’) is a partition of ‘racecar’ into two groups.<a id="more"></a><br>Given a sequence of charac- ters, we can always create a par- tition of these characters such that each group in the partition is a palindrome! Given this ob- servation it is natural to ask: what is the minimum number of groups needed for a given string such that every group is a palin- drome?</p>
<p>For example:<br>• ‘racecar’ is already a palindrome, therefore it can be partitioned into one group.<br>• ‘fastcar’ does not con- tain any non-trivial palin- dromes, so it must be par- titioned as (‘f’, ‘a’, ‘s’, ‘t’, ‘c’, ‘a’, ‘r’).<br>• ‘aaadbccb’ can be parti- tioned as (‘aaa’, ‘d’, ‘bccb’).</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>Can you read upside-down?<br>Input begins with the number n of test cases. Each test case consists of a single line of between 1 and 1000 lowercase letters, with no whitespace within.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, output a line containing the minimum number of groups required to partition the input into groups of palindromes.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>给定一个字符串，判断最少有多少个回文串。<br>显然是线性结构上的 DP，设<strong>状态</strong><code>d[i]</code>为$1\sim i$的字符串中最少有多少个回文串，用两层$for$循环遍历，<strong>状态转移</strong>方程为<code>d[i] = min(d[i], d[j] + 1)</code>，表示$j+1\sim i$是一个回文串，然后决策。</p>
<p>每一次循环都需要判断回文串，所以先进行预处理，把所有回文串找出来。注意回文串有奇数长度和偶数长度的。<strong>时间复杂度</strong>包括预处理的$O(n^2)$和 dp 的$O(n^2)$。</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn]; <span class="comment">// d[i] 表示为 1~i 最少有多少个回文串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> s[maxn];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>); <span class="comment">// 空出0的位置，后面 dp 的时候就可以判断 a[1][i]</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++) &#123; <span class="comment">// 预处理，先将所有的回文串标记出来</span></span><br><span class="line">      a[i][i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> l=i<span class="number">-1</span>,r=i+<span class="number">1</span>,b1=<span class="number">1</span>,b2=<span class="number">1</span>; l+<span class="number">1</span>&gt;<span class="number">0</span> &amp;&amp; r&lt;=len; l--,r++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;<span class="number">0</span> &amp;&amp; s[l] != s[r]) b1 = <span class="number">0</span>; <span class="comment">// l~r 长度为奇数</span></span><br><span class="line">        a[l][r] = b1;</span><br><span class="line">        <span class="keyword">if</span>(s[l+<span class="number">1</span>] != s[r]) b2 = <span class="number">0</span>; <span class="comment">// l+1~r 长度为偶数</span></span><br><span class="line">        a[l+<span class="number">1</span>][r] = b2;</span><br><span class="line">        <span class="keyword">if</span>(!b1 &amp;&amp; !b2) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++) &#123;</span><br><span class="line">      d[i] = i; <span class="comment">// 初始化 d[i], 最多只有 i 个</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">        <span class="keyword">if</span>(a[j+<span class="number">1</span>][i]) d[i] = <span class="built_in">min</span>(d[i], d[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[len]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DP</category>
        <category>线性结构上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>uva</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title>uva116 Unidirection TSP 多段图DP</title>
    <url>/2020/04/05/uva116-Unidirection-TSP-%E5%A4%9A%E6%AE%B5%E5%9B%BEDP/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-116" target="_blank" rel="noopener">uva116 Unidirectional TSP</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Problems that require minimum paths through some domain appear in many different areas of computer science. For example, one of the constraints in VLSI routing problems is minimizing wire length. The Traveling Salesperson Problem (TSP) — finding whether all the cities in a salesperson’s route can be visited exactly once with a specified limit on travel time — is one of the canonical examples of an NP-complete problem; solutions appear to require an inordinate amount of time to generate, but are simple to check.<a id="more"></a></p>
<p>This problem deals with finding a minimal path through a grid of points while traveling only from left to right.</p>
<p>Given an m × n matrix of integers, you are to write a program that computes a path of minimal weight. A path starts anywhere in column 1 (the first column) and consists of a sequence of steps terminating in column n (the last column). A step consists of traveling from column i to column i + 1 in an adjacent (horizontal or diagonal) row. The first and last rows (rows 1 and m) of a matrix are considered adjacent, i.e., the matrix “wraps” so that it represents a horizontal cylinder. Legal steps are illustrated on the right.</p>
<p>The weight of a path is the sum of the integers in each of the n cells of the matrix that are visited. For example, two slightly different 5×6 matrices are shown below (the only difference is the numbers in the bottom row).</p>
<p>The minimal path is illustrated for each matrix. Note that the path for the matrix on the right takes advantage of the adjacency property of the first and last rows.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input consists of a sequence of matrix specifications. Each matrix specification consists of the row and column dimensions in that order on a line followed by m · n integers where m is the row dimension and n is the column dimension. The integers appear in the input in row major order, i.e., the first n integers constitute the first row of the matrix, the second n integers constitute the second row and so on. The integers on a line will be separated from other integers by one or more spaces. Note: integers are not restricted to being positive.</p>
<p>There will be one or more matrix specifications in an input file. Input is terminated by end-of-file.</p>
<p>For each specification the number of rows will be between 1 and 10 inclusive; the number of columns will be between 1 and 100 inclusive. No path’s weight will exceed integer values representable using 30 bits.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Two lines should be output for each matrix specification in the input file, the first line represents a minimal-weight path, and the second line is the cost of a minimal path. The path consists of a sequence of n integers (separated by one or more spaces) representing the rows that constitute the minimal path. If there is more than one path of minimal weight the path that is lexicographically smallest should be output.</p>
<p>Note: Lexicographically means the natural order on sequences induced by the order on their elements.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>从矩阵第一列出发，到达最后一列，每一列是一个阶段，每个状态可以往右上、右、右下移动，所以一共有三个决策，求最短路径。</p>
<p>用$d(i, j)$表示<strong>状态</strong>，从第$i$行第$j$列<strong>出发</strong>，还需要走多远到达终点，<strong>状态转移</strong>方程为：$d(i, j)=min(d(i-1, j+1), d(i, j+1), d(i+1, j+1))$</p>
<p>在动态规划的过程中可以用一个$next$表将每个结点的最优后继存下来，到时候直接打印路径。</p>
<h4 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxm][maxn], d[maxm][maxn], next[maxm][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = INF, first; <span class="comment">// first 用于记录路径的开始（头）</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(j == n<span class="number">-1</span>) d[i][j] = a[i][j]; <span class="comment">// 边界</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> rows[] = &#123;i<span class="number">-1</span>, i, i+<span class="number">1</span>&#125;; <span class="comment">// 往下一列移动</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) rows[<span class="number">0</span>] = m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == m<span class="number">-1</span>) rows[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(rows, rows+<span class="number">3</span>); <span class="comment">// 按字典序排序</span></span><br><span class="line">        d[i][j] = INF; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">3</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">int</span> v = a[i][j] + d[rows[k]][j+<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span>(v &lt; d[i][j]) &#123;d[i][j] = v; next[i][j] = rows[k];&#125; <span class="comment">// 顺便记录下路径</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j == <span class="number">0</span> &amp;&amp; d[i][j] &lt; ans) &#123;ans = d[i][j]; first = i;&#125; <span class="comment">// 记录下答案路径的头</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, first+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>, i=next[first][<span class="number">0</span>]; j&lt;n; i=next[i][j], j++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, i+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> m, n;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n) == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">    dp(m, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>多阶段决策问题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>uva</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>uva1347 Tour 记忆化搜索和递推</title>
    <url>/2020/04/05/uva1347-Tour-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%92%8C%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-1347" target="_blank" rel="noopener">uva1347 Tour</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>John Doe, a skilled pilot, enjoys traveling. While on vacation, he rents a small plane and starts visiting beautiful places. To save money, John must determine the shortest closed tour that connects his destinations. Each destination is represented by a point in the plane pi =&lt; xi,yi &gt;. John uses the following strategy: he starts from the leftmost point, then he goes strictly left to right to the rightmost point, and then he goes strictly right back to the starting point. It is known that the points have distinct x-coordinates.<a id="more"></a></p>
<p>Write a program that, given a set of n points in the plane, computes the shortest closed tour that connects the points according to John’s strategy.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The program input is from a text file. Each data set in the file stands for a particular set of points. For each set of points the data set contains the number of points, and the point coordinates in ascending order of the x coordinate. White spaces can occur freely in input. The input data are correct.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each set of data, your program should print the result to the standard output from the beginning of a line. The tour length, a floating-point number with two fractional digits, represents the result.</p>
<p>Note: An input/output sample is in the table below. Here there are two data sets. The first one contains 3 points specified by their x and y coordinates. The second point, for example, has the x coordinate 2, and the y coordinate 3. The result for each data set is the tour length, (6.47 for the first data set in the given example).</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目是需要找一条从起点到终点再回到起点的最短路，且除了起点和终点外每个点都仅经过一次。可以转化成两个人同时从起点出发，最后都到达终点的最短路。</p>
<p>用<code>i</code>和<code>j</code>当前所在点作为<strong>状态</strong>，然后定义<code>dp(i, j)</code>为<strong>从当前状态出发</strong>，还需要多远才能到达终点，且<code>0~max(i, j)</code>都已经走过了。由于需要保证每个都需要且仅经过一次，所以设置每次只让<code>i</code>或者<code>j</code>往前走一步，为了便于处理，设置<code>i&gt;j</code>。当<code>i</code>往前走一步则变为<code>(i+1, j)</code>；当<code>j</code>往前走一步则变为<code>(i, i+1)</code>，由于<code>i&gt;j</code>，所以变成<code>(i+1, i)</code>。每个状态的<strong>决策</strong>是两个，时间复杂度为$O(n^2)$。</p>
<p>这样即可推出<strong>状态转移方程</strong>：<code>dp(i, j) = min(dp(i+1, j) + dis(i, i+1), dp(i+1, i) + dis(j, i+1))</code>。<em>（dis 为两点之间的距离）</em></p>
<p>分别用两种方法实现：记忆化搜索、递推</p>
<h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], n;</span><br><span class="line"><span class="keyword">double</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>((x[i]-x[j]), <span class="number">2</span>) + <span class="built_in">pow</span>((y[i]-y[j]), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i == n<span class="number">-1</span>) <span class="keyword">return</span> d[i][j] = dis(i, j); <span class="comment">// 终止条件，返回 j 到 n-1 的距离即可</span></span><br><span class="line">  <span class="keyword">if</span>(d[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[i][j]; <span class="comment">// 已经搜索过，直接返回</span></span><br><span class="line">  <span class="keyword">return</span> d[i][j] = <span class="built_in">min</span>(dis(i, i+<span class="number">1</span>) + dp(i+<span class="number">1</span>, j), dis(j, i+<span class="number">1</span>) + dp(i+<span class="number">1</span>, i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, dp(<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 答案为起始点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], n;</span><br><span class="line"><span class="keyword">double</span> dis[maxn][maxn], dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 提前计算好每两点的距离</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;=n; j++)</span><br><span class="line">        dis[i][j] = dis[j][i] = <span class="built_in">sqrt</span>((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">2</span>; i--) <span class="comment">// dp(i, j) 定义为从该点出发，还需要走多远；倒着递推</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++) <span class="comment">// dp(i, j) == dp(j, i)，始终令 i &gt; j，便于处理</span></span><br><span class="line">        <span class="keyword">if</span>(i == n<span class="number">-1</span>) dp[i][j] = dis[j][n] + dis[i][n]; <span class="comment">// 边界</span></span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j] + dis[i][i+<span class="number">1</span>], dp[i+<span class="number">1</span>][i] + dis[j][i+<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, dp[<span class="number">2</span>][<span class="number">1</span>] + dis[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 起始点为答案，即 dp[1][1] = dp[2][1] + dis[1][2]</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>DAG上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>uva</tag>
        <tag>递推</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>uva12563 Jin Ge Jin Qu hao 01背包+滚动数组</title>
    <url>/2020/04/05/uva12563-Jin-Ge-Jin-Qu-hao-01%E8%83%8C%E5%8C%85-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-12563#author=0" target="_blank" rel="noopener">uva12563 Jin Ge Jin Qu hao</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>(If you smiled when you see the title, this problem is for you ^_^)</p>
<p>For those who don’t know KTV, see: <a href="http://en.wikipedia.org/wiki/Karaoke_box" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Karaoke_box</a></p>
<p>There is one very popular song called Jin Ge Jin Qu(). It is a mix of 37 songs, and is extremely long (11 minutes and 18 seconds) — I know that there are Jin Ge Jin Qu II and III, and some other unofficial versions. But in this problem please forget about them.<a id="more"></a></p>
<p>Why is it popular? Suppose you have only 15 seconds left (until your time is up), then you should select another song as soon as possible, because the KTV will not crudely stop a song before it ends (people will get frustrated if it does so!). If you select a 2-minute song, you actually get 105 extra seconds! ….and if you select Jin Ge Jin Qu, you’ll get 663 extra seconds!!!</p>
<p>Now that you still have some time, but you’d like to make a plan now. You should stick to the following rules:</p>
<p>• Don’t sing a song more than once (including Jin Ge Jin Qu).<br>• For each song of length t, either sing it for exactly t seconds, or don’t sing it at all.<br>• When a song is finished, always immediately start a new song.</p>
<p>Your goal is simple: sing as many songs as possible, and leave KTV as late as possible (since we have rule 3, this also maximizes the total lengths of all songs we sing) when there are ties.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line contains the number of test cases T (T ≤ 100). Each test case begins with two positive integers n, t (1 ≤ n ≤ 50, 1 ≤ t ≤ $10^9$), the number of candidate songs (BESIDES Jin Ge Jin Qu) and the time left (in seconds). The next line contains n positive integers, the lengths of each song, in seconds. Each length will be less than 3 minutes — I know that most songs are longer than 3 minutes. But don’t forget that we could manually “cut” the song after we feel satisfied, before the song ends. So here “length” actually means “length of the part that we want to sing”.</p>
<p>It is guaranteed that the sum of lengths of all songs (including Jin Ge Jin Qu) will be strictly larger than t.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print the maximum number of songs (including Jin Ge Jin Qu), and the total lengths of songs that you’ll sing.</p>
<p>Explanation:</p>
<p>In the first example, the best we can do is to sing the third song (80 seconds), then Jin Ge Jin Qu for another 678 seconds.</p>
<p>In the second example, we sing the first two (30+69=99 seconds). Then we still have one second left, so we can sing Jin Ge Jin Qu for extra 678 seconds. However, if we sing the first and third song instead (30+70=100 seconds), the time is already up (since we only have 100 seconds in total), so we can’t sing Jin Ge Jin Qu anymore!</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>在$t$秒内从$n$首歌中选取尽可能多的曲目数量，典型的01背包。由于最后需要留时间来唱劲歌金曲，所以不能把所有的$t$都用完，至少需要留1秒。最后答案记得加上劲歌金曲。</p>
<p>注意虽然题目给的$t&lt;=10^9$，但是由于每首歌不超过3分钟，最多50首歌，所有实际上$t$不会超过$180*n + 678$。</p>
<p>特别注意，最后答案需要求总的时长，所以不能单纯使用01背包的模板，因为无法知道总共花费的时间，01背包模板的答案存储在<code>d[1][C]</code>或者<code>d[n][C]</code>，但是这个答案的总时长很可能是不对的，因为不要用到这么多时间。所以这里要特殊处理，将初始值全都弄成一个很小的负值，然后将 <code>d[0]</code>设为0，意思是正好将时间用完的才会记录成正数，否则如果用完还有剩，虽然会进行+1操作，但是依旧是很小的负值。</p>
<h4 id="01背包-滚动数组"><a href="#01背包-滚动数组" class="headerlink" title="01背包+滚动数组"></a>01背包+滚动数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxm]; <span class="comment">// d 是歌曲数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> T, n, t, v, ans;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> kase=<span class="number">1</span>; kase&lt;=T; kase++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;t);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x8f</span>, <span class="keyword">sizeof</span>(d)); <span class="comment">// 初始化成一个很小的负数</span></span><br><span class="line">    d[<span class="number">0</span>] = ans = <span class="number">0</span>; <span class="comment">// 将d[0]标记成0，ans 用于记录最大的歌曲数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=t<span class="number">-1</span>; j&gt;=v; j--) &#123;</span><br><span class="line">        d[j] = <span class="built_in">max</span>(d[j], d[j-v] + <span class="number">1</span>); <span class="comment">// 采用滚动数组，减少存储空间，需要 j 反向遍历</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, d[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=t<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) <span class="keyword">if</span>(d[j] == ans) &#123; <span class="comment">// 直接用 ans 来找出总时长</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Case %d: %d %d\n"</span>, kase, ans + <span class="number">1</span>, j + <span class="number">678</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>多阶段决策问题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>uva</tag>
        <tag>01背包</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
</search>
