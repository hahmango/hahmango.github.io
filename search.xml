<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>uva1347 Tour 记忆化搜索和递推</title>
    <url>/2020/04/05/uva1347-Tour-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%92%8C%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-1347" target="_blank" rel="noopener">uva1347 Tour</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>John Doe, a skilled pilot, enjoys traveling. While on vacation, he rents a small plane and starts visiting beautiful places. To save money, John must determine the shortest closed tour that connects his destinations. Each destination is represented by a point in the plane pi =&lt; xi,yi &gt;. John uses the following strategy: he starts from the leftmost point, then he goes strictly left to right to the rightmost point, and then he goes strictly right back to the starting point. It is known that the points have distinct x-coordinates.</p>
<p>Write a program that, given a set of n points in the plane, computes the shortest closed tour that connects the points according to John’s strategy.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The program input is from a text file. Each data set in the file stands for a particular set of points. For each set of points the data set contains the number of points, and the point coordinates in ascending order of the x coordinate. White spaces can occur freely in input. The input data are correct.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each set of data, your program should print the result to the standard output from the beginning of a line. The tour length, a floating-point number with two fractional digits, represents the result.</p>
<p>Note: An input/output sample is in the table below. Here there are two data sets. The first one contains 3 points specified by their x and y coordinates. The second point, for example, has the x coordinate 2, and the y coordinate 3. The result for each data set is the tour length, (6.47 for the first data set in the given example).</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目是需要找一条从起点到终点再回到起点的最短路，且除了起点和终点外每个点都仅经过一次。可以转化成两个人同时从起点出发，最后都到达终点的最短路。</p>
<p>用<code>i</code>和<code>j</code>当前所在点作为<strong>状态</strong>，然后定义<code>dp(i, j)</code>为<strong>从当前状态出发</strong>，还需要多远才能到达终点，且<code>0~max(i, j)</code>都已经走过了。由于需要保证每个都需要且仅经过一次，所以设置每次只让<code>i</code>或者<code>j</code>往前走一步，为了便于处理，设置<code>i&gt;j</code>。当<code>i</code>往前走一步则变为<code>(i+1, j)</code>；当<code>j</code>往前走一步则变为<code>(i, i+1)</code>，由于<code>i&gt;j</code>，所以变成<code>(i+1, i)</code>。每个状态的<strong>决策</strong>是两个，时间复杂度为$O(n^2)$。</p>
<p>这样即可推出<strong>状态转移方程</strong>：<code>dp(i, j) = min(dp(i+1, j) + dis(i, i+1), dp(i+1, i) + dis(j, i+1))</code>。<em>（dis 为两点之间的距离）</em></p>
<p>分别用两种方法实现：记忆化搜索、递推</p>
<h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], n;</span><br><span class="line"><span class="keyword">double</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>((x[i]-x[j]), <span class="number">2</span>) + <span class="built_in">pow</span>((y[i]-y[j]), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i == n<span class="number">-1</span>) <span class="keyword">return</span> d[i][j] = dis(i, j); <span class="comment">// 终止条件，返回 j 到 n-1 的距离即可</span></span><br><span class="line">  <span class="keyword">if</span>(d[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[i][j]; <span class="comment">// 已经搜索过，直接返回</span></span><br><span class="line">  <span class="keyword">return</span> d[i][j] = <span class="built_in">min</span>(dis(i, i+<span class="number">1</span>) + dp(i+<span class="number">1</span>, j), dis(j, i+<span class="number">1</span>) + dp(i+<span class="number">1</span>, i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, dp(<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 答案为起始点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], n;</span><br><span class="line"><span class="keyword">double</span> dis[maxn][maxn], dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 提前计算好每两点的距离</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;=n; j++)</span><br><span class="line">        dis[i][j] = dis[j][i] = <span class="built_in">sqrt</span>((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">2</span>; i--) <span class="comment">// dp(i, j) 定义为从该点出发，还需要走多远；倒着递推</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++) <span class="comment">// dp(i, j) == dp(j, i)，始终令 i &gt; j，便于处理</span></span><br><span class="line">        <span class="keyword">if</span>(i == n<span class="number">-1</span>) dp[i][j] = dis[j][n] + dis[i][n]; <span class="comment">// 边界</span></span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j] + dis[i][i+<span class="number">1</span>], dp[i+<span class="number">1</span>][i] + dis[j][i+<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, dp[<span class="number">2</span>][<span class="number">1</span>] + dis[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 起始点为答案，即 dp[1][1] = dp[2][1] + dis[1][2]</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>DAG上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>记忆化搜索</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>uva12563 Jin Ge Jin Qu hao 01背包+滚动数组</title>
    <url>/2020/04/05/uva12563-Jin-Ge-Jin-Qu-hao-01%E8%83%8C%E5%8C%85-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-12563#author=0" target="_blank" rel="noopener">uva12563 Jin Ge Jin Qu hao</a></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>(If you smiled when you see the title, this problem is for you ^_^)</p>
<p>For those who don’t know KTV, see: <a href="http://en.wikipedia.org/wiki/Karaoke_box" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Karaoke_box</a></p>
<p>There is one very popular song called Jin Ge Jin Qu(). It is a mix of 37 songs, and is extremely long (11 minutes and 18 seconds) — I know that there are Jin Ge Jin Qu II and III, and some other unofficial versions. But in this problem please forget about them.</p>
<p>Why is it popular? Suppose you have only 15 seconds left (until your time is up), then you should select another song as soon as possible, because the KTV will not crudely stop a song before it ends (people will get frustrated if it does so!). If you select a 2-minute song, you actually get 105 extra seconds! ….and if you select Jin Ge Jin Qu, you’ll get 663 extra seconds!!!</p>
<p>Now that you still have some time, but you’d like to make a plan now. You should stick to the following rules:</p>
<p>• Don’t sing a song more than once (including Jin Ge Jin Qu).<br>• For each song of length t, either sing it for exactly t seconds, or don’t sing it at all.<br>• When a song is finished, always immediately start a new song.</p>
<p>Your goal is simple: sing as many songs as possible, and leave KTV as late as possible (since we have rule 3, this also maximizes the total lengths of all songs we sing) when there are ties.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line contains the number of test cases T (T ≤ 100). Each test case begins with two positive integers n, t (1 ≤ n ≤ 50, 1 ≤ t ≤ $10^9$), the number of candidate songs (BESIDES Jin Ge Jin Qu) and the time left (in seconds). The next line contains n positive integers, the lengths of each song, in seconds. Each length will be less than 3 minutes — I know that most songs are longer than 3 minutes. But don’t forget that we could manually “cut” the song after we feel satisfied, before the song ends. So here “length” actually means “length of the part that we want to sing”.</p>
<p>It is guaranteed that the sum of lengths of all songs (including Jin Ge Jin Qu) will be strictly larger than t.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print the maximum number of songs (including Jin Ge Jin Qu), and the total lengths of songs that you’ll sing.</p>
<p>Explanation:</p>
<p>In the first example, the best we can do is to sing the third song (80 seconds), then Jin Ge Jin Qu for another 678 seconds.</p>
<p>In the second example, we sing the first two (30+69=99 seconds). Then we still have one second left, so we can sing Jin Ge Jin Qu for extra 678 seconds. However, if we sing the first and third song instead (30+70=100 seconds), the time is already up (since we only have 100 seconds in total), so we can’t sing Jin Ge Jin Qu anymore!</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>在$t$秒内从$n$首歌中选取尽可能多的曲目数量，典型的01背包。由于最后需要留时间来唱劲歌金曲，所以不能把所有的$t$都用完，至少需要留1秒。最后答案记得加上劲歌金曲。</p>
<p>注意虽然题目给的$t&lt;=10^9$，但是由于每首歌不超过3分钟，最多50首歌，所有实际上$t$不会超过$180*n + 678$。</p>
<p>特别注意，最后答案需要求总的时长，所以不能单纯使用01背包的模板，因为无法知道总共花费的时间，01背包模板的答案存储在<code>d[1][C]</code>或者<code>d[n][C]</code>，但是这个答案的总时长很可能是不对的，因为不要用到这么多时间。所以这里要特殊处理，将初始值全都弄成一个很小的负值，然后将 <code>d[0]</code>设为0，意思是正好将时间用完的才会记录成正数，否则如果用完还有剩，虽然会进行+1操作，但是依旧是很小的负值。</p>
<h4 id="01背包-滚动数组"><a href="#01背包-滚动数组" class="headerlink" title="01背包+滚动数组"></a>01背包+滚动数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxm]; <span class="comment">// d 是歌曲数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> T, n, t, v, ans;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> kase=<span class="number">1</span>; kase&lt;=T; kase++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;t);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x8f</span>, <span class="keyword">sizeof</span>(d)); <span class="comment">// 初始化成一个很小的负数</span></span><br><span class="line">    d[<span class="number">0</span>] = ans = <span class="number">0</span>; <span class="comment">// 将d[0]标记成0，ans 用于记录最大的歌曲数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=t<span class="number">-1</span>; j&gt;=v; j--) &#123;</span><br><span class="line">        d[j] = <span class="built_in">max</span>(d[j], d[j-v] + <span class="number">1</span>); <span class="comment">// 采用滚动数组，减少存储空间，需要 j 反向遍历</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, d[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=t<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) <span class="keyword">if</span>(d[j] == ans) &#123; <span class="comment">// 直接用 ans 来找出总时长</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Case %d: %d %d\n"</span>, kase, ans + <span class="number">1</span>, j + <span class="number">678</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>多阶段决策问题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>01背包</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title>uva116 Unidirection TSP 多段图DP</title>
    <url>/2020/04/05/uva116-Unidirection-TSP-%E5%A4%9A%E6%AE%B5%E5%9B%BEDP/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-116" target="_blank" rel="noopener">uva116 Unidirectional TSP</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Problems that require minimum paths through some domain appear in many different areas of computer science. For example, one of the constraints in VLSI routing problems is minimizing wire length. The Traveling Salesperson Problem (TSP) — finding whether all the cities in a salesperson’s route can be visited exactly once with a specified limit on travel time — is one of the canonical examples of an NP-complete problem; solutions appear to require an inordinate amount of time to generate, but are simple to check.</p>
<p>This problem deals with finding a minimal path through a grid of points while traveling only from left to right.</p>
<p>Given an m × n matrix of integers, you are to write a program that computes a path of minimal weight. A path starts anywhere in column 1 (the first column) and consists of a sequence of steps terminating in column n (the last column). A step consists of traveling from column i to column i + 1 in an adjacent (horizontal or diagonal) row. The first and last rows (rows 1 and m) of a matrix are considered adjacent, i.e., the matrix “wraps” so that it represents a horizontal cylinder. Legal steps are illustrated on the right.</p>
<p>The weight of a path is the sum of the integers in each of the n cells of the matrix that are visited. For example, two slightly different 5×6 matrices are shown below (the only difference is the numbers in the bottom row).</p>
<p>The minimal path is illustrated for each matrix. Note that the path for the matrix on the right takes advantage of the adjacency property of the first and last rows.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input consists of a sequence of matrix specifications. Each matrix specification consists of the row and column dimensions in that order on a line followed by m · n integers where m is the row dimension and n is the column dimension. The integers appear in the input in row major order, i.e., the first n integers constitute the first row of the matrix, the second n integers constitute the second row and so on. The integers on a line will be separated from other integers by one or more spaces. Note: integers are not restricted to being positive.</p>
<p>There will be one or more matrix specifications in an input file. Input is terminated by end-of-file.</p>
<p>For each specification the number of rows will be between 1 and 10 inclusive; the number of columns will be between 1 and 100 inclusive. No path’s weight will exceed integer values representable using 30 bits.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Two lines should be output for each matrix specification in the input file, the first line represents a minimal-weight path, and the second line is the cost of a minimal path. The path consists of a sequence of n integers (separated by one or more spaces) representing the rows that constitute the minimal path. If there is more than one path of minimal weight the path that is lexicographically smallest should be output.</p>
<p>Note: Lexicographically means the natural order on sequences induced by the order on their elements.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>从矩阵第一列出发，到达最后一列，每一列是一个阶段，每个状态可以往右上、右、右下移动，所以一共有三个决策，求最短路径。</p>
<p>用$d(i, j)$表示<strong>状态</strong>，从第$i$行第$j$列<strong>出发</strong>，还需要走多远到达终点，<strong>状态转移</strong>方程为：$d(i, j)=min(d(i-1, j+1), d(i, j+1), d(i+1, j+1))$</p>
<p>在动态规划的过程中可以用一个$next$表将每个结点的最优后继存下来，到时候直接打印路径。</p>
<h4 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxm][maxn], d[maxm][maxn], next[maxm][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = INF, first; <span class="comment">// first 用于记录路径的开始（头）</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(j == n<span class="number">-1</span>) d[i][j] = a[i][j]; <span class="comment">// 边界</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> rows[] = &#123;i<span class="number">-1</span>, i, i+<span class="number">1</span>&#125;; <span class="comment">// 往下一列移动</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) rows[<span class="number">0</span>] = m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == m<span class="number">-1</span>) rows[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(rows, rows+<span class="number">3</span>); <span class="comment">// 按字典序排序</span></span><br><span class="line">        d[i][j] = INF; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">3</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">int</span> v = a[i][j] + d[rows[k]][j+<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span>(v &lt; d[i][j]) &#123;d[i][j] = v; next[i][j] = rows[k];&#125; <span class="comment">// 顺便记录下路径</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j == <span class="number">0</span> &amp;&amp; d[i][j] &lt; ans) &#123;ans = d[i][j]; first = i;&#125; <span class="comment">// 记录下答案路径的头</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, first+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>, i=next[first][<span class="number">0</span>]; j&lt;n; i=next[i][j], j++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, i+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> m, n;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n) == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">    dp(m, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>多阶段决策问题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>uva11400 Lighting System Design 线性结构DP</title>
    <url>/2020/04/05/uva11400-Lighting-System-Design-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84DP/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-11400" target="_blank" rel="noopener">uva11400 Lighting System Design</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>You are given the task to design a lighting system for a huge conference hall. After doing a lot of calculation and sketching, you have figured out the requirements for an energy-efficient design that can properly illuminate the entire hall. According to your design, you need lamps of n different power ratings. For some strange current regulation method, all the lamps need to be fed with the same amount of current. So, each category of lamp has a corresponding voltage rating. Now, you know the number of lamps and cost of every single unit of lamp for each category. But the problem is, you are to buy equivalent voltage sources for all the lamp categories. You can buy a single voltage source for each category (Each source is capable of supplying to infinite number of lamps of its voltage rating.) and complete the design. But the accounts section of your company soon figures out that they might be able to reduce the total system cost by eliminating some of the voltage sources and replacing the lamps of that category with higher rating lamps. Certainly you can never replace a lamp by a lower rating lamp as some portion of the hall might not be illuminated then. You are more concerned about money-saving than energy-saving. Find the minimum possible cost to design the system.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>Each case in the input begins with n (1 ≤ n ≤ 1000), denoting the number of categories. Each of the following n lines describes a category. A category is described by 4 integers - V (1 ≤ V ≤ 132000), the voltage rating, K (1 ≤ K ≤ 1000), the cost of a voltage source of this rating, C (1 ≤ C ≤ 10), the cost of a lamp of this rating and L (1 ≤ L ≤ 100), the number of lamps required in this category. The input terminates with a test case where n = 0. This case should not be processed.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print the minimum possible cost to design the system.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>有一个照明系统需要用到n种灯，每种灯的电压为V，电源费用K，每个灯泡费用为C，需要该灯的数量为L。注意到，电压相同的灯泡只需要共享一个对应的电源即可，还有电压低的灯泡可以被电压高的灯泡替代。为了节约成本，你将设计一种系统，使之最便宜。</p>
<p>意思是这 n 种灯已经模拟了可以使用并且打算被安装，但是可以想办法节约成本。</p>
<p>由于只能是电压低的灯泡被电压高的灯泡替换，所以先按电压进行排序。<br>在替换的时候，对于某一种灯泡，显然是要么不换，要么全替换。（如果能替换一部分，那么说明替换的灯泡成本更低，那么肯定是全部替换）</p>
<p>这属于线性结构上的 DP，直接使用$i$来表示<strong>状态</strong>即可。<br>设s[i]为前i种灯泡的总数量(即L值之和)，<code>d[i]</code>以<code>i</code>为终点，表示为灯泡<code>1~i</code>的最小开销，则<strong>状态转移方程</strong>为<code>d[i] = min(d[i], d[j] + (s[i]-s[j])*c[i] + k[i]))</code>，表示前$j$个先用最优方案买，然后<code>j+1~i</code>个都用第$i$号的电源。答案为<code>d[n]</code>。</p>
<p>不能用外层循环只去替换内层的当前那种灯泡，假如用当前这个$i$替换掉了一个$j$的灯泡，这样就错了，前面的灯泡可能用的是他的电源，而你无法修改<code>d[j]</code>本身的值。</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lamp</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, k, c, l;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> lamp &amp;r) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; r.v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn], s[maxn]; <span class="comment">// d[i] 为灯泡 1~i 的最小开销；s[i] 为前 i 种灯泡的总个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    lamp &amp;u = a[i];</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] + u.l;</span><br><span class="line">    d[i] = s[i]*u.c + u.k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)</span><br><span class="line">      d[i] = <span class="built_in">min</span>(d[i], d[j] + (s[i]-s[j])*u.c + u.k); <span class="comment">// 表示之前j个先按j的最优方案买，然后之后的 j+1~i 都用 i 的灯泡</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n, v, k, c, l;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">      lamp &amp;u = a[i];</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u.v, &amp;u.k, &amp;u.c, &amp;u.l);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">    dp(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[n]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DP</category>
        <category>线性结构上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
</search>
