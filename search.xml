<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020 Wuhan University Collegiate Programming Contest (Preliminary Contest)--A Monument For Heroes</title>
    <url>/2020/04/13/2020-Wuhan-University-Collegiate-Programming-Contest-Preliminary-Contest-A-Monument-For-Heroes/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5166/A" target="_blank" rel="noopener">A Monument For Heroes</a></p>
<h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>Months ago, the COVID-19 swept Wuhan. In order to control the outbreak, many people tried their best to help Wuhan, and with their help, we finally (almost) beat the virus, so we are going to set up a monument and write the names of all the contributors to express our gratitude to them. But there are so many people who have helped Wuhan so there are so many names to write, and how to arrange them is a big problem, so we decided that we will choose some representative names and rearrange their order to make them neatly. But until now we still do not know the maximum length of letters that will be write on the monument. We cannot leave enough space for these names without this number, so we leave this problem for you. <a id="more"></a></p>
<p>Now you will be given the name of all the contributors, and you can choose some and connect them in a certain order to make them neat. A permutation of names is neat only when for every component except the last one, the last letter of the component is the same as the first letter of the next component, and the last letter of the whole name is the same as the first one. E.g. if there are 3 contributors called ”abc”, “fga”, “cdef”, we can choose all these three names and combine them to “abccdeffga” to write on the monument with length of 10. </p>
<p>What’s more, these contributors agreed that one who contributed more is more important. They will provide you a preference list according to their agreement and you should connect the permutation <strong>strictly</strong> according to the list. That is, if a name $s$ appears earlier than name $t$ in the preference list, ss would also appear earlier than tt if they are both selected into the permutations. </p>
<p>There will be many permutations which are neat, but we should leave enough space for every possible one, so can you tell us the length of the longest one? </p>
<p>Note: there might be multiple contributors have the same name.</p>
<h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h4><p>The first line contains integer $(1 ≤ n ≤ 2*10^5)$ — the number of contributors. Next $n$ lines contain $n$ names, one per line. A contributor’s name is a non-empty sequence of lowercase Latin letters. Its length does not exceed $10$ characters.</p>
<p>Meanwhile, this is a preference list, the name comes earlier should also appear earlier in your final permutation.</p>
<h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h4><p>Print a single number – the maximum length of combination of names. If there are no possible permutations, print $0$ instead.</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>输入</p>
<blockquote>
<p>3<br>abc<br>ca<br>cba </p>
</blockquote>
<p>输出</p>
<blockquote>
<p>6</p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目是从给定一个字符串序列中，找出能连接的最长的序列长度，其中的每个字符串的相互顺序不能变。注意还需要保证最后形成的子序列的首尾是相同的字符。</p>
<p>在读取字符串的时候，直接进行处理，将首字母、尾字母和长度记录下来，便于后面处理。</p>
<p>由于是通过字符来连接，那么就可以使用遍历所有字符串，每次循环遍历所有字母的方式来 DP，每次最多只需要比较26次，将<code>d[i][j]</code>表示为以当前字符串作为起点，首字母为 $i$，遍历所有字母 $j$ 作为打算拼接的尾字母，能形成的最长的序列的长度，状态转移方程为 $d(i, j) = \{max(d(i, j), d(last_i, j)+len_i)\quad |\quad d(last_i, j)&gt;0\}$。需要保证 $d(last_i, j)&gt;0$ 才进行决策，否则就相当于和一个不存在的字符串进行了拼接。和自身字符串长度的比较要放后面，否则如果先记录当前字符串的长度，假设当前字符串首尾都是 a，当 $last_i = j = ‘a’$ 时，就会导致<code>d[a][a]</code>的长度翻倍。</p>
<p>最后遍历一遍首尾字母相同的 $d$ 值，找出最长的长度。</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">27</span>][<span class="number">27</span>], fi[maxn], la[maxn], len[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n, l, ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">12</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    l = <span class="built_in">strlen</span>(s);</span><br><span class="line">    fi[i] = s[<span class="number">0</span>]-<span class="string">'a'</span>; la[i] = s[l<span class="number">-1</span>]-<span class="string">'a'</span>; len[i] = l;</span><br><span class="line">  &#125;</span><br><span class="line">  d[fi[n]][la[n]] = len[n];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">26</span>; j++)</span><br><span class="line">      <span class="keyword">if</span>(d[la[i]][j])</span><br><span class="line">        d[fi[i]][j] = <span class="built_in">max</span>(d[fi[i]][j], len[i] + d[la[i]][j]);</span><br><span class="line">    d[fi[i]][la[i]] = <span class="built_in">max</span>(d[fi[i]][la[i]], len[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d[i][i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>牛客竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 Wuhan University Collegiate Programming Contest (Preliminary Contest)--Best Match</title>
    <url>/2020/04/13/2020-Wuhan-University-Collegiate-Programming-Contest-Preliminary-Contest-Best-Match/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5166/B" target="_blank" rel="noopener">Best Match</a></p>
<h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>There is a traditional activity held by school of computer science in WuHan University: Five-day lovers. But this year, due to COVID-19, this event has to be held online and <strong>HamsterW</strong> wants to organize this activity to help schoolmates who have no girlfriend or boyfriend. <a id="more"></a></p>
<p><strong>HamsterW</strong> knows a lot about opposites attract theory. That is the key principle of this Five-day lovers. The Five-day lovers activity has classified each registered schoolmates according his/her interests and assigned to the $i-th$ schoolmate number $t_i(-20 \leq t_i \leq 20)$ . A number will be assigned randomly to any schoolmates.</p>
<p><strong>HamsterW</strong> wants to advertise this activity and inform the number of opposite matches, that is, matches who have opposite values of $t$. There are two schoolmates in a match. The schoolmate can join multiple groups at the same time.</p>
<p>For example, if $t=(1, -1, 1, -1)$, then any two elements $t_i$ and $t_j$ form a match if $i≠j$. Consequently, in this case the result is equal to 4. Of course, a schoolmate can’t date with him/herself.</p>
<p>Help <strong>HamsterW</strong> and write the program that will find the result by the given sequence $t_1,t_2,…,t_n$. Maybe one of you will be in these matched cases.</p>
<h4 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h4><p>The first line of the input data contains an integer $n \quad (1 \leq n \leq 5*10^5)$ which represents the number of registered schoolmates of the Five-day lovers.<br>The second line contains a sequence of integers $t_1,t_2,…,t_n(-20 \leq t_i \leq 20)$, $t_i$ is the parameter of the $i-th$ schoolmate that has been assigned to the schoolmate by the result of the analysis of his interests.</p>
<h4 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h4><p>Print the number of matches of schoolmates with opposite $t$. The opposite number for $x$ is number $−x$ ( 0 is opposite to itself ).</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目是求配对的数量，直接用桶存储所有数，求所有数的正数和负数的乘积相加，再加上 0 的 $n$ 项等差数列的累加和即可。注意要<code>long long</code>。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">21</span>], zn, q[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n, c;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">    <span class="keyword">if</span>(c &gt; <span class="number">0</span>) q[c]++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c &lt; <span class="number">0</span>) p[-c]++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ans += zn;</span><br><span class="line">      zn++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">20</span>; i++)</span><br><span class="line">    ans += p[i] * q[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>牛客竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 Wuhan University Collegiate Programming Contest (Preliminary Contest)--E Yu is a Brutal Creature</title>
    <url>/2020/04/13/2020-Wuhan-University-Collegiate-Programming-Contest-Preliminary-Contest-E-Yu-is-a-Brutal-Creature/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5166/E" target="_blank" rel="noopener">E Yu is a Brutal Creature</a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题意是找出 0 到 n 之间所有满足 $\frac{n^2+1}{n+1}$ 为整数的数的个数。由于</p>
<script type="math/tex; mode=display">
\frac{n^2+1}{n+1}=\frac{n^2+n}{n+1}-\frac{n-1}{n+1}=n-\frac{n-1}{n+1}</script><p>显然，只有当 $n=0$ 或 $1$ 的时候，式子才会是整数，所以答案是 $n-1$。<a id="more"></a></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> T, n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>牛客竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 Wuhan University Collegiate Programming Contest (Preliminary Contest)--DIY Masks at Home</title>
    <url>/2020/04/13/2020-Wuhan-University-Collegiate-Programming-Contest-Preliminary-Contest-DIY-Masks-at-Home/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5166/D" target="_blank" rel="noopener">DIY Masks at Home</a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题意是给你一个由大写字母构成的二维矩阵，你需要在其中找到一个最大的正方形，使得这个正方形内只包含一种字母，输出正方形的边长。<a id="more"></a></p>
<p>有两种方法：</p>
<ol>
<li><p>一种是直接 DP，遍历每一个块，用<code>d[i][j]</code>表示以 $(i, j)$ 为右下角坐标，能行成的最大的正方形的边长是多少。<strong>状态转移</strong>方程为 $d(i, j) = min(d(i-1, j-1), min(d(i-1, j), d(i, j-1)))$，每一次都与 $(i-1,j-1),(i-1,j),(i,j-1)$ 三个点判断是否能形成同一个颜色正方形。注意也需要对 $d(i-1, j-1)$ 进行决策，因为会有这种情况：$(i, j)$ 这个方块的左边和上面都是两个正方形，而 $(i-1, j-1)$ 只是这两个正方形的交点，所以他会影响<code>d[i][j]</code>的大小。<br>时间复杂度：$O(nm)$</p>
</li>
<li><p>另一种方法是用二分，每次去找当前划分后的矩阵是否是同一个颜色的正方形，找不到的话继续划分，找到了直接跳出。<br>时间复杂度：$O(nmlog(n))$</p>
</li>
</ol>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> g[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> T, n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, g[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">        d[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(g[i<span class="number">-1</span>][j<span class="number">-1</span>]==g[i][j] &amp;&amp; g[i<span class="number">-1</span>][j]==g[i][j] &amp;&amp; g[i][j<span class="number">-1</span>]==g[i][j])</span><br><span class="line">          d[i][j] = <span class="built_in">min</span>(d[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(d[i<span class="number">-1</span>][j], d[i][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, d[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>牛客竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年 第十一届 蓝桥杯省赛模拟</title>
    <url>/2020/04/15/2020%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>这是第十一届蓝桥杯省模拟赛的试题和题解，C++组的，前四个是填空题，有点奇葩，后六个大题，难度总的来说还好，个人觉得倒数第二题比较难，看来还得多练啊。<a id="more"></a></p>
<h3 id="1-算字节"><a href="#1-算字节" class="headerlink" title="1. 算字节"></a>1. 算字节</h3><p>问题描述<br>　　在计算机存储中，12.5MB是多少字节？</p>
<p>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p>
<blockquote>
<p>答案为 $12.5 \ast 1024 \ast 1024=13107200$</p>
</blockquote>
<p><del>话说怎么又出了这种题</del></p>
<hr>
<h3 id="2-括号序列"><a href="#2-括号序列" class="headerlink" title="2. 括号序列"></a>2. 括号序列</h3><p>问题描述<br>　　由1对括号，可以组成一种合法括号序列：<code>()</code>。<br>　　由2对括号，可以组成两种合法括号序列：<code>()()、(())</code>。<br>　　由4对括号组成的合法括号序列一共有多少种？</p>
<p>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p>
<blockquote>
<p>4对括号组成的合法括号序列有：<br>1层：<code>()()()(): 1</code><br>2层：<code>(())()(): 3, (())(()): 1, (()())(): 2, (()()()): 1</code><br>3层：<code>((())()): 2, ((()())): 1, ((()))(): 2</code><br>4层：<code>(((()))): 1</code><br>所以一共是<code>14</code>种</p>
</blockquote>
<hr>
<h3 id="3-边数"><a href="#3-边数" class="headerlink" title="3. 边数"></a>3. 边数</h3><p>问题描述<br>　　一个包含有2019个结点的无向连通图，最少包含多少条边？</p>
<p>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p>
<blockquote>
<p><code>n</code> 个结点的无向连通图，最少有<code>n-1</code>条边，再少就不连通了<br>答案为<code>2018</code></p>
</blockquote>
<hr>
<h3 id="4-字母排列"><a href="#4-字母排列" class="headerlink" title="4. 字母排列"></a>4. 字母排列</h3><p>问题描述<br>　　将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。<br>　　请问，总共能排列如多少个不同的单词。</p>
<p>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p>
<blockquote>
<p>7个字母求排列：$A_7^7$<br>由于有两个字母相同，所以要除以 $A_2^2$<br>答案为：$\frac{A_7^7}{A_2^2}=2520$</p>
</blockquote>
<hr>
<h3 id="5-反倍数"><a href="#5-反倍数" class="headerlink" title="5. 反倍数"></a>5. 反倍数</h3><p>问题描述<br>　　给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。<br>　　请问在 1 至 n 中有多少个反倍数。</p>
<p>输入格式<br>　　输入的第一行包含一个整数 n。<br>　　第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。</p>
<p>输出格式<br>　　输出一行包含一个整数，表示答案。</p>
<p>样例输入<br>30<br>2 3 6</p>
<p>样例输出<br>10</p>
<p>样例说明<br>　　以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。</p>
<p>评测用例规模与约定<br>　　对于 40% 的评测用例，1 &lt;= n &lt;= 10000。<br>　　对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000000，1 &lt;= a &lt;= n，1 &lt;= b &lt;= n，1 &lt;= c &lt;= n。</p>
<p>直接全部遍历一遍，每个数都对 a, b, c 分别求余，能整除就不要</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, a, b, c, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;c);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(i%a &amp;&amp; i%b &amp;&amp; i%c) ans++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="6-凯撒密码"><a href="#6-凯撒密码" class="headerlink" title="6. 凯撒密码"></a>6. 凯撒密码</h3><p>问题描述<br>　　给定一个单词，请使用凯撒密码将这个单词加密。<br>　　凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，…，w变为z，x变为a，y变为b，z变为c。<br>　　例如，lanqiao会变成odqtldr。</p>
<p>输入格式<br>　　输入一行，包含一个单词，单词中只包含小写英文字母。</p>
<p>输出格式<br>　　输出一行，表示加密后的密文。</p>
<p>样例输入<br>lanqiao</p>
<p>样例输出<br>odqtldr</p>
<p>评测用例规模与约定<br>　　对于所有评测用例，单词中的字母个数不超过100。</p>
<p>先让每个字母变成整数，再<code>+3</code>然后对 26 取模就行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[maxn];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    c = (<span class="keyword">char</span>)(s[i]-<span class="string">'a'</span>+<span class="number">3</span>)%<span class="number">26</span>+<span class="string">'a'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="7-蛇形填数"><a href="#7-蛇形填数" class="headerlink" title="7. 蛇形填数"></a>7. 蛇形填数</h3><p>问题描述<br>　　对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。<br>　　例如，一个 4 行 5 列的螺旋矩阵如下：<br>　　1 2 3 4 5<br>　　14 15 16 17 6<br>　　13 20 19 18 7<br>　　12 11 10 9 8</p>
<p>输入格式<br>　　输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。<br>　　第二行包含两个整数 r, c，表示要求的行号和列号。</p>
<p>输出格式<br>　　输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。</p>
<p>样例输入<br>4 5<br>2 2</p>
<p>样例输出<br>15</p>
<p>评测用例规模与约定<br>　　对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。<br>　　对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。<br>　　对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= r &lt;= n，1 &lt;= c &lt;= m。</p>
<p>循环填数，每次循环填一圈数。一共 $n*m$ 个数，填满就跳出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, r, c, x, y, cnt, tn;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;r, &amp;c);</span><br><span class="line">  tn = n * m;</span><br><span class="line">  cnt = a[x=<span class="number">0</span>][y=<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(cnt &lt; tn) &#123;</span><br><span class="line">    <span class="keyword">while</span>(y+<span class="number">1</span> &lt; m &amp;&amp; !a[x][y+<span class="number">1</span>]) a[x][++y] = ++cnt;</span><br><span class="line">    <span class="keyword">while</span>(x+<span class="number">1</span> &lt; n &amp;&amp; !a[x+<span class="number">1</span>][y]) a[++x][y] = ++cnt;</span><br><span class="line">    <span class="keyword">while</span>(y<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; !a[x][y<span class="number">-1</span>]) a[x][--y] = ++cnt;</span><br><span class="line">    <span class="keyword">while</span>(x<span class="number">-1</span> &gt;=<span class="number">0</span> &amp;&amp; !a[x<span class="number">-1</span>][y]) a[--x][y] = ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[r<span class="number">-1</span>][c<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="8-摆动序列-DP"><a href="#8-摆动序列-DP" class="headerlink" title="8. 摆动序列 DP"></a>8. 摆动序列 DP</h3><p>问题描述<br>　　如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 $a[2i]<a[2i-1]$, $a[2i+1]>a[2i]$。<br>　　小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。</p>
<p>输入格式<br>　　输入一行包含两个整数 m，n。</p>
<p>输出格式<br>　　输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。</p>
<p>样例输入<br>3 4</p>
<p>样例输出<br>14</p>
<p>样例说明<br>　　以下是符合要求的摆动序列：<br>　　2 1 2<br>　　2 1 3<br>　　2 1 4<br>　　3 1 2<br>　　3 1 3<br>　　3 1 4<br>　　3 2 3<br>　　3 2 4<br>　　4 1 2<br>　　4 1 3<br>　　4 1 4<br>　　4 2 3<br>　　4 2 4<br>　　4 3 4</p>
<p>评测用例规模与约定<br>　　对于 20% 的评测用例，1 &lt;= n, m &lt;= 5；<br>　　对于 50% 的评测用例，1 &lt;= n, m &lt;= 10；<br>　　对于 80% 的评测用例，1 &lt;= n, m &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n, m &lt;= 1000。</p>
<p>一道<code>DP</code>题，外圈循环依次遍历<code>m</code>个位置，内圈循环对当前位置尝试填<code>n</code>个数。<strong><code>d[i][j]</code></strong>表示当前第<code>i</code>个位置放<code>j</code>，整个<code>1~i</code>的所有序列共有多少种选择。这里需要分情况，如果当前位置是奇数，则他需要比前一个数大，如果当前位置放<code>j</code>的话，则前一个位置上的数为<code>1~j-1</code>的都满足，而当前位置放<code>j-1</code>的所有序列肯定也被放<code>j</code>的包含，所以奇数位置时，正序填数，<strong>状态转移</strong>方程为<code>d[i][j] = (d[i-1][j-1] + d[i][j-1])</code>。偶数位置也同理，偶数位就逆序填数，<strong>状态转移</strong>方程为<code>d[i][j] = (d[i-1][j+1] + d[i][j+1])</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn]; <span class="comment">// d[i][j] 表示第 i 个位置放 j，整个 1~i 的序列共有多少种选择</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m, n, ans=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) d[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;=n; j++) d[i][j] = (d[i<span class="number">-1</span>][j<span class="number">-1</span>] + d[i][j<span class="number">-1</span>]) % <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;=<span class="number">1</span>; j--) d[i][j] = (d[i<span class="number">-1</span>][j+<span class="number">1</span>] + d[i][j+<span class="number">1</span>]) % <span class="number">10000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) ans = (ans + d[m][j]) % <span class="number">10000</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="9-植树"><a href="#9-植树" class="headerlink" title="9. 植树"></a>9. 植树</h3><p>问题描述<br>　　小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。<br>　　小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。<br>　　然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。<br>　　他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。<br>　　小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。</p>
<p>输入格式<br>　　输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。<br>　　接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。</p>
<p>输出格式<br>　　输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。</p>
<p>样例输入<br>6<br>1 1 2<br>1 4 2<br>1 7 2<br>4 1 2<br>4 4 2<br>4 7 2</p>
<p>样例输出<br>12</p>
<p>评测用例规模与约定<br>　　对于 30% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 20；<br>　　对于所有评测用例，1 &lt;= n &lt;= 30，0 &lt;= x, y &lt;= 1000，1 &lt;= r &lt;= 1000。</p>
<p>这题实在没什么思路，用 DFS 暴力搜的。尽管靠能冲突能剪枝，但是还是指数级的，$O(n)=2^n$，之后会了再进行改进。<br>这里我先预处理冲突，将所有冲突计算出来，之后就可以不用每次重复计算，直接判断即可。DFS 的搜索树是 $n$ 层的二叉树，每次决策种这棵树和不种这棵树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], r[maxn], ar[maxn], n, d[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> conflict[maxn][maxn], a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isconflict</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((x[u]-x[v])*(x[u]-x[v]) + (y[u]-y[v])*(y[u]-y[v])) &lt; r[u]+r[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inline void see() &#123;for(int i=1; i&lt;=n; i++) if(a[i])printf(" %d", i); printf("\n");&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(u == n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> ans = dfs(u+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;u; i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i] &amp;&amp; conflict[i][u]) <span class="keyword">return</span> ans;</span><br><span class="line">  a[u] = <span class="number">1</span>;</span><br><span class="line">  ans = <span class="built_in">max</span>(ans, dfs(u+<span class="number">1</span>) + ar[u]);</span><br><span class="line">  a[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x[i], &amp;y[i], &amp;r[i]);</span><br><span class="line">    ar[i] = r[i] * r[i]; <span class="comment">// 计算面积</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 预先计算冲突</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      <span class="keyword">if</span>(isconflict(i, j)) conflict[i][j] = conflict[j][i] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, dfs(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="10-村庄通电-Kruskal-并查集"><a href="#10-村庄通电-Kruskal-并查集" class="headerlink" title="10. 村庄通电 Kruskal+并查集"></a>10. 村庄通电 Kruskal+并查集</h3><p>问题描述<br>　　2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。<br>　　这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。<br>　　现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。<br>　　小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 (x_1, y_1) 高度为 h_1 的村庄与坐标为 (x_2, y_2) 高度为 h_2 的村庄之间连接的费用为<br>　　$\sqrt{((x_1-x_2)<em>(x_1-x_2)+(y_1-y_2)</em>(y_1-y_2))}+(h_1-h_2)*(h_1-h_2)$。<br>　　在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。<br>　　由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。</p>
<p>输入格式<br>　　输入的第一行包含一个整数 n ，表示村庄的数量。<br>　　接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。</p>
<p>输出格式<br>　　输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。</p>
<p>样例输入<br>4<br>1 1 3<br>9 9 7<br>8 8 6<br>4 5 4</p>
<p>样例输出<br>17.41</p>
<p>评测用例规模与约定<br>　　对于 30% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000，0 &lt;= x, y, h &lt;= 10000。</p>
<p>这题算是比较标准的最小生成树模板题，我这里采用的是 Kruskal，首先读入<code>n</code>个村庄，然后生成 他们每两点之间的边，放到优先队列里进行堆排。然后进行 Kruskal 算法，每次取最小的边加入结果集中，如果加入的边会导致产生环，则不加入，就是说加入的边的两个点必须属于两个不同的连通分量，如果他们已经在同一个连通分量中，则再加入必然会导致产生环。这里使用了并查集来优化连通分量的查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">double</span> w;</span><br><span class="line">  node(<span class="keyword">int</span> u=<span class="number">0</span>, <span class="keyword">int</span> v=<span class="number">0</span>, <span class="keyword">double</span> w=<span class="number">0</span>) : u(u), v(v), w(w) &#123;&#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;r) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> w &gt; r.w;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], h[maxn], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x[i], &amp;y[i], &amp;h[i]);</span><br><span class="line">  priority_queue&lt;node&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 将边从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      q.push(node(i, j, <span class="built_in">sqrt</span>((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j])) + (h[i]-h[j])*(h[i]-h[j])));</span><br><span class="line">  <span class="comment">// Kruskal</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) p[i] = i; <span class="comment">// 初始化并查集</span></span><br><span class="line">  node u;</span><br><span class="line">  <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    u = q.top(); q.pop();</span><br><span class="line">    <span class="keyword">int</span> x=<span class="built_in">find</span>(u.u), y=<span class="built_in">find</span>(u.v); <span class="comment">// 找两点各自所在的连通分量</span></span><br><span class="line">    <span class="keyword">if</span>(x != y) &#123;ans += u.w; p[x] = y;&#125; <span class="comment">// 若不在同一个连通分量，则合并连通分量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.2f"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>蓝桥杯</tag>
        <tag>Kruskal</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #636 (Div. 3) A. Candies</title>
    <url>/2020/05/05/Codeforces-Round-636-Div-3-A-Candies/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1343/problem/A" target="_blank" rel="noopener">A. Candies</a></p>
<p>Recently Vova found 𝑛 candy wrappers. He remembers that he bought 𝑥 candies during the first day, 2𝑥 candies during the second day, 4𝑥 candies during the third day, ……, $2^{𝑘−1}𝑥$ candies during the 𝑘-th day. But there is an issue: Vova remembers neither 𝑥 nor 𝑘 but he is sure that 𝑥 and 𝑘 are positive integers and 𝑘&gt;1.<a id="more"></a></p>
<p>Vova will be satisfied if you tell him <strong>any positive</strong> integer 𝑥 so there is an integer 𝑘&gt;1 that $𝑥+2𝑥+4𝑥+⋯+2^{𝑘−1}𝑥=𝑛$. It is guaranteed that at least one solution exists. <strong>Note that 𝑘&gt;1.</strong></p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line of the input contains one integer t (1≤𝑡≤104) — the number of test cases. Then 𝑡 test cases follow.</p>
<p>The only line of the test case contains one integer 𝑛 (3≤𝑛≤109) — the number of candy wrappers Vova found. It is guaranteed that there is some positive integer 𝑥 and integer 𝑘&gt;1 that $𝑥+2𝑥+4𝑥+⋯+2^{𝑘−1}𝑥=𝑛$.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Print one integer — any positive integer value of 𝑥 so there is an integer 𝑘&gt;1 that $𝑥+2𝑥+4𝑥+⋯+2^{𝑘−1}𝑥=𝑛$.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>第 $i$ 天买 $2^{i−1}𝑥$ 个糖果，一共有 $n$ 张糖纸，求可能的 $x$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
𝑥+2𝑥+4𝑥+⋯+2^{𝑘−1}𝑥=(2^k-1)*x &= n\\
x &= \frac{n}{2^k-1}
\end{aligned}</script><p>枚举 $k$，直到满足 $n \% 2^{𝑘−1}=0$。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> t, n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, x=<span class="number">0</span>;</span><br><span class="line">    rep(k, <span class="number">2</span>, n) &#123;</span><br><span class="line">      a *= <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(n % (a<span class="number">-1</span>) == <span class="number">0</span>) &#123; x = n / (a<span class="number">-1</span>); <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第198场周赛 1518.换酒问题</title>
    <url>/2020/07/22/LeetCode%20%E7%AC%AC198%E5%9C%BA%E5%91%A8%E8%B5%9B%201518.%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/water-bottles/" target="_blank" rel="noopener">LeetCode 1518. 换酒问题</a></p>
<p>小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。</p>
<p>如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。</p>
<p>请你计算 最多 能喝到多少瓶酒。<a id="more"></a></p>
<h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>输入：numBottles = 9, numExchange = 3<br>输出：13<br>解释：你可以用 3 个空酒瓶兑换 1 瓶酒。<br>所以最多能喝到 9 + 3 + 1 = 13 瓶酒。</p>
<p>输入：numBottles = 15, numExchange = 4<br>输出：19<br>解释：你可以用 4 个空酒瓶兑换 1 瓶酒。<br>所以最多能喝到 15 + 3 + 1 = 19 瓶酒。</p>
<p>输入：numBottles = 5, numExchange = 5<br>输出：6</p>
<p>输入：numBottles = 2, numExchange = 3<br>输出：2</p>
<p>提示：</p>
<p>1 &lt;= numBottles &lt;= 100<br>2 &lt;= numExchange &lt;= 100</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>直接使用<code>while</code>循环，每一轮都喝掉所有酒，然后用酒瓶换酒（直接除法就可以求得能换到几瓶酒），更新酒的数量。当空酒瓶数量不足以换酒时，退出循环。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWaterBottles</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=n, a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            a = n / m;</span><br><span class="line">            ans += a;</span><br><span class="line">            n = a + n % m;</span><br><span class="line">            <span class="keyword">if</span>(n &lt; m) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第198场周赛 1519.子树中标签相同的节点数</title>
    <url>/2020/07/22/LeetCode-%E7%AC%AC198%E5%9C%BA%E5%91%A8%E8%B5%9B-1519-%E5%AD%90%E6%A0%91%E4%B8%AD%E6%A0%87%E7%AD%BE%E7%9B%B8%E5%90%8C%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/" target="_blank" rel="noopener">LeetCode 1519.子树中标签相同的节点数</a></p>
<p>给你一棵树（即，一个连通的无环无向图），这棵树由编号从 0  到 n - 1 的 n 个节点组成，且恰好有 n - 1 条 edges 。树的根节点为节点 0 ，树上的每一个节点都有一个标签，也就是字符串 labels 中的一个小写字符（编号为 i 的 节点的标签就是 labels[i] ）<a id="more"></a></p>
<p>边数组 edges 以 edges[i] = [ai, bi] 的形式给出，该格式表示节点 ai 和 bi 之间存在一条边。</p>
<p>返回一个大小为 n 的数组，其中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数。</p>
<p>树 T 中的子树是由 T 中的某个节点及其所有后代节点组成的树。</p>
<h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>输入：n = 4, edges = [[0,1],[1,2],[0,3]], labels = “bbbb”<br>输出：[4,2,1,1]<br>解释：节点 2 的子树中只有节点 2 ，所以答案为 1 。<br>节点 3 的子树中只有节点 3 ，所以答案为 1 。<br>节点 1 的子树中包含节点 1 和 2 ，标签都是 ‘b’ ，因此答案为 2 。<br>节点 0 的子树中包含节点 0、1、2 和 3，标签都是 ‘b’，因此答案为 4 。</p>
<p>输入：n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = “aabab”<br>输出：[3,2,1,1,1]</p>
<p>输入：n = 6, edges = [[0,1],[0,2],[1,3],[3,4],[4,5]], labels = “cbabaa”<br>输出：[1,2,1,1,2,1]</p>
<p>输入：n = 7, edges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]], labels = “aaabaaa”<br>输出：[6,5,4,1,3,2,1]</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 10^5<br>edges.length == n - 1<br>edges[i].length == 2<br>0 &lt;= ai, bi &lt; n<br>ai != bi<br>labels.length == n<br>labels 仅由小写英文字母组成</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>先将输入的边用邻接链表法构造成树（图），好遍历，然后直接DFS后序遍历一遍。需要用一个数组<code>vis</code>记录是否遍历过这个节点。因为是想要知道以当前节点为根的子树共有多少个与当前节点相同的label，所以在每次遍历到一个新的节点时，记录下目前共有多少个与当前节点相同的label，然后遍历完了以当前节点为根的子树之后回到当前节点，再记录一下目前共有多少个与当前节点相同的label，他们的差值就是以当前节点为根的子树所有的与当前节点相同的label个数。</p>
<h4 id="DFS后序遍历"><a href="#DFS后序遍历" class="headerlink" title="DFS后序遍历"></a>DFS后序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a;</span><br><span class="line">    <span class="keyword">int</span> val[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSubTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; eg, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        a = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n);</span><br><span class="line">        ans = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : eg) &#123; <span class="comment">// 构造邻接链表</span></span><br><span class="line">            a[i[<span class="number">0</span>]].push_back(i[<span class="number">1</span>]);</span><br><span class="line">            a[i[<span class="number">1</span>]].push_back(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, n, s);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> n, <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(u &gt;= n) <span class="keyword">return</span> ;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; u &lt;&lt; " ";</span></span><br><span class="line">        <span class="keyword">int</span> pre = val[s[u]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : a[u])</span><br><span class="line">            dfs(i, n, s);</span><br><span class="line">        ans[u] = ++val[s[u]-<span class="string">'a'</span>] - pre; <span class="comment">// 计算差值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #636 (Div. 3) B. Balanced Array</title>
    <url>/2020/05/05/Codeforces-Round-636-Div-3-B-Balanced-Array/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1343/problem/B" target="_blank" rel="noopener">B. Balanced Array</a></p>
<p>You are given a positive integer 𝑛, it is guaranteed that 𝑛 is even (i.e. divisible by 2).</p>
<p>You want to construct the array 𝑎 of length 𝑛n such that: </p>
<ul>
<li>The first $\frac{𝑛}{2}$ elements of 𝑎 are even (divisible by 2); </li>
<li>the second $\frac{𝑛}{2}$ elements of 𝑎 are odd (not divisible by 2); </li>
<li><strong>all elements of 𝑎 are distinct and positive</strong>; </li>
<li>the sum of the first half equals to the sum of the second half ($\sum_{i=1}^{\frac{n}{2}}a_i=\sum_{i=\frac{n}{2}+1}^{n}a_i$). <a id="more"></a></li>
</ul>
<p>If there are multiple answers, you can print any. It is <strong>not guaranteed</strong> that the answer exists.</p>
<p>You have to answer 𝑡 independent test cases.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line of the input contains one integer 𝑡 ($1≤𝑡≤10^4$) — the number of test cases. Then 𝑡 test cases follow.</p>
<p>The only line of the test case contains one integer 𝑛n ($2≤𝑛≤2⋅10^5$) — the length of the array. It is guaranteed that that 𝑛n is even (i.e. divisible by 2).</p>
<p>It is guaranteed that the sum of 𝑛 over all test cases does not exceed $2⋅10^5$ ($∑𝑛≤2⋅10^5$).</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print the answer — “NO” (without quotes), if there is no suitable answer for the given test case or “YES” in the first line and <strong>any</strong> suitable array $𝑎1,𝑎2,…,𝑎𝑛 (1≤𝑎_𝑖≤10^9)$ satisfying conditions from the problem statement on the second line.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>若 $\frac{n}{2}$ 是奇数的话，则无论如何也不能满足条件。所以若 $\frac{n}{2}$ 是奇数的话可以直接输出 NO；偶数的话则一定可以满足，直接从 n 的左右两边同时取 $\frac{n}{4}$ 个奇数和偶数即可，这样奇数之和必然等于偶数之后，都等于 $\frac{n^2}{2}$。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> t, n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>((n/<span class="number">2</span>) % <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n/<span class="number">2</span>; i+=<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d "</span>, n-i, n+i); <span class="comment">// 左右两边同时取 n/4 个偶数</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n/<span class="number">2</span>; i+=<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d "</span>, n - i, n + i); <span class="comment">// 左右两边同时取 n/4 个奇数</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #636 (Div. 3) E. Weights Distributing 排序+BFS</title>
    <url>/2020/05/05/Codeforces-Round-636-Div-3-E-Weights-Distributing/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1343/problem/E" target="_blank" rel="noopener">Codeforces Round #636 (Div. 3) E. Weights Distributing</a></p>
<p>You are given an undirected unweighted graph consisting of 𝑛 vertices and 𝑚 edges (which represents the map of Bertown) and the array of prices 𝑝 of length 𝑚. It is guaranteed that there is a path between each pair of vertices (districts).<a id="more"></a></p>
<p>Mike has planned a trip from the vertex (district) 𝑎 to the vertex (district) 𝑏 and then from the vertex (district) 𝑏 to the vertex (district) 𝑐. He can visit the same district twice or more. But there is one issue: authorities of the city want to set a price for using the road so if someone goes along the road then he should pay the price corresponding to this road (<strong>he pays each time he goes along the road</strong>). The list of prices that will be used 𝑝 is ready and they just want to distribute it between all roads in the town in such a way that each price from the array corresponds to exactly one road.</p>
<p>You are a good friend of Mike (and suddenly a mayor of Bertown) and want to help him to make his trip as cheap as possible. So, your task is to distribute prices between roads in such a way that if Mike chooses the optimal path then the price of the trip is the <strong>minimum</strong>possible. <strong>Note that you cannot rearrange prices after the start of the trip</strong>.</p>
<p>You have to answer 𝑡 independent test cases.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line of the input contains one integer 𝑡 ($1≤𝑡≤10^4$) — the number of test cases. Then 𝑡t test cases follow.</p>
<p>The first line of the test case contains five integers 𝑛,𝑚,𝑎,𝑏 and 𝑐 ($2≤𝑛≤2⋅10^5, 𝑛−1≤𝑚≤𝑚𝑖𝑛(𝑛(𝑛−1)/2),2⋅10^5$), 1≤𝑎,𝑏,𝑐≤𝑛) — the number of vertices, the number of edges and districts in Mike’s trip.</p>
<p>The second line of the test case contains 𝑚 integers 𝑝1,𝑝2,…,𝑝𝑚 ($1≤𝑝_𝑖≤10^9$), where $𝑝_𝑖$ is the 𝑖-th price from the array.</p>
<p>The following 𝑚 lines of the test case denote edges: edge 𝑖 is represented by a pair of integers 𝑣𝑖, 𝑢𝑖 (1≤𝑣𝑖,𝑢𝑖≤𝑛, 𝑢𝑖≠𝑣𝑖), which are the indices of vertices connected by the edge. There are no loops or multiple edges in the given graph, i. e. for each pair (𝑣𝑖,𝑢𝑖) there are no other pairs (𝑣𝑖,𝑢𝑖) or (𝑢𝑖,𝑣𝑖) in the array of edges, and for each pair (𝑣𝑖,𝑢𝑖) the condition 𝑣𝑖≠𝑢𝑖 is satisfied. It is guaranteed that the given graph is connected.</p>
<p>It is guaranteed that the sum of 𝑛 (as well as the sum of 𝑚) does not exceed $2⋅10^5$ ($∑𝑛≤2⋅10^5, ∑𝑚≤2⋅10^5$).</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print the answer — the <strong>minimum</strong> possible price of Mike’s trip if you distribute prices between edges optimally.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>给你一个 n 个点 m 条边的无向无权图，一个长度为 m 的数组 p，以及三个地点 A,B,C 现在你可以任意将 $p_1…p_m$ 一一对应给每一条边作为边权，问你 a→b→c 的最短路径是多少?</p>
<p>对于 a→b→c 有两种情况：</p>
<ol>
<li>a→b→c 路径在一条线上，可以看做一条直线，样例2就是这种情况。</li>
<li>a→b→c 路径不在一条线上，不能看做一条直线，路径中存在一个交叉结点 x，使得 a→b→c 为 a-&gt;x-&gt;b-&gt;x-&gt;c，这种情况显然有一段路会重复经过，即 x-b，样例1就是这种情况。</li>
</ol>
<p>其实情况1是情况2的一种特殊情形，即 b=x。</p>
<p>利用贪心思想，先用 BFS 求出 a, b, c 三点到每个点的最短路径的长度，然后枚举每一个结点作为中间交叉结点 x，找出一共所经过的的路径的最少的段数 k，然后从需要分配的路段价格中取出 k 段路的价格，答案就是这个的和。</p>
<p>三段 BFS 的时间复杂度为 $O(3n)$，枚举的时间复杂度为 $O(n)$，找最小的路段价格可以先排序，时间复杂度为 $O(nlog(n))$，所以总时间复杂度为 $O(nlog(n))$。</p>
<h4 id="排序-BFS"><a href="#排序-BFS" class="headerlink" title="排序+BFS"></a>排序+BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line">ll pref[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;vi&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, vi &amp;d)</span> </span>&#123;</span><br><span class="line">  d[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(s);</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;to : g[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span>(d[to] == inf) &#123;</span><br><span class="line">        d[to] = d[u] + <span class="number">1</span>;</span><br><span class="line">        q.push(to);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> t, n, m, a, b, c, x, y;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;n, &amp;m, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">    sort(p+<span class="number">1</span>, p+m+<span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, m)</span><br><span class="line">      pref[i] = pref[i<span class="number">-1</span>] + p[i];</span><br><span class="line">    g = <span class="built_in">vector</span>&lt;vi&gt; (n+<span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">      g[x].pb(y); g[y].pb(x);</span><br><span class="line">    &#125;</span><br><span class="line">    vi da(n+1, inf), db(n+1, inf), dc(n+1, inf); // inf 不能太大；d：表示到某个点的路径长度</span><br><span class="line">    bfs(a, da); bfs(b, db); bfs(c, dc);</span><br><span class="line">    ll ans = (ll)<span class="number">1</span>&lt;&lt;<span class="number">62</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123; <span class="comment">// 枚举中间交叉结点</span></span><br><span class="line">      <span class="keyword">if</span>(da[i] + db[i] + dc[i] &gt; m) <span class="keyword">continue</span>; <span class="comment">// 注意如果 inf 太大的话，加法可能会溢出</span></span><br><span class="line">      ans = <span class="built_in">min</span>(ans, pref[db[i]] + pref[da[i] + db[i] + dc[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #636 (Div. 3) C. Alternating Subsequence</title>
    <url>/2020/05/05/Codeforces-Round-636-Div-3-C-Alternating-Subsequence/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1343/problem/C" target="_blank" rel="noopener">C. Alternating Subsequence</a></p>
<p>Recall that the sequence 𝑏 is a subsequence of the sequence 𝑎 if 𝑏 can be derived from 𝑎 by removing zero or more elements without changing the order of the remaining elements. For example, if 𝑎=[1,2,1,3,1,2,1], then possible subsequences are: [1,1,1,1], [3]and [1,2,1,3,1,2,1], but not [3,2,3] and [1,1,1,1,2].<a id="more"></a></p>
<p>You are given a sequence 𝑎 consisting of 𝑛 positive and negative elements (there is no zeros in the sequence).</p>
<p>Your task is to choose <strong>maximum by size</strong> (length) <em>alternating</em> subsequence of the given sequence (i.e. the sign of each next element is the opposite from the sign of the current element, like positive-negative-positive and so on or negative-positive-negative and so on). Among all such subsequences, you have to choose one which has the <strong>maximum sum</strong> of elements.</p>
<p>In other words, if the maximum length of <em>alternating</em> subsequence is 𝑘 then your task is to find the <strong>maximum sum</strong> of elements of some <em>alternating</em> subsequence of length 𝑘.</p>
<p>You have to answer 𝑡 independent test cases.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line of the input contains one integer 𝑡 ($1≤𝑡≤10^4$) — the number of test cases. Then 𝑡 test cases follow.</p>
<p>The first line of the test case contains one integer 𝑛 ($1≤𝑛≤2⋅10^5$) — the number of elements in 𝑎. The second line of the test case contains 𝑛 integers 𝑎1,𝑎2,…,𝑎𝑛 ($−10^9≤𝑎_𝑖≤10^9,𝑎_𝑖≠0$), where $𝑎_𝑖$ is the 𝑖-th element of 𝑎.</p>
<p>It is guaranteed that the sum of 𝑛 over all test cases does not exceed $2⋅10^5$ ($∑𝑛≤2⋅10^5$).</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print the answer — the <strong>maximum sum</strong> of the <strong>maximum by size</strong> (length) <em>alternating</em> subsequence of 𝑎.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题意是先求出最长的一个子序列，这个子序列必须是正负交替的，然后在这个的基础上求子序列和最大的一个子序列。首先，在每个区间中，这个区间里的每个数正负号都相同，区间的个数就是最长的子序列的长度，然后在每个这种区间中取最大的那个数就行。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> t, n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">bool</span> isPos = a[<span class="number">1</span>] &gt; <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = a[<span class="number">1</span>];</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">2</span>, n)</span><br><span class="line">      <span class="keyword">if</span>((a[i] &gt; <span class="number">0</span>) == isPos) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, a[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        isPos = !isPos;</span><br><span class="line">        sum += ans;</span><br><span class="line">        ans = a[i];</span><br><span class="line">      &#125;</span><br><span class="line">    sum += ans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>P1020 导弹拦截 LIS问题</title>
    <url>/2020/04/30/P1020-%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA-LIS%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1020" target="_blank" rel="noopener">P1020 导弹拦截</a></p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。<a id="more"></a></p>
<p>输入导弹依次飞来的高度（雷达给出的高度数据是 ≤ 50000 的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>1行，若干个整数（个数 ≤100000）</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>2行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题意第一问就是从给定的序列中求出<strong>最长不上升子序列</strong>的长度，这个就是最多能拦截的导弹的个数。第二问其实本质就是求一个<strong>最长上升子序列</strong>的长度，这个可以用反证法证明，我们假设最少要配备 $K$ 套拦截系统，将他们各自拦截的导弹分为 $K$ 组，并且按照他们拦截的最后一个导弹的出现顺序进行排序，他们末尾的导弹则为 $A_1, A_2,\ldots , A_k$， 若他们末尾的导弹不是一个最长上升子序列，则说明存在 $A_i, A_j$ ，$i &lt; j$ 且 $A_i \geq A_j$， 这显然是不可能的，因为 $A_i \geq A_j$，且 $A_j$ 在 $A_i$ 后面出现，则 $A_j$ 必然能被 $A_i$ 那套系统打掉，所以他们就是一个最长上升子序列。</p>
<p>然后就是套用 LIS 的 DP+二分求解，将<code>d[i]</code>的<code>i</code>定义为子序列的长度，而<strong><code>d[i]</code></strong> 存放子序列长度为<code>i</code>的序列的末尾的数，对于第一问的最长不上升子序列，查看长度为<code>len</code>的子序列的尾数是否大于或等于当前的数，如果是，则说明可以接到他这个子序列上；如果小于，则二分查找，直到找到一个刚好比这个数小一点的数，将其替换。对于第二问的也是同理，只是判断大于小于需要变一下。时间复杂度为 $O(nlog(n))$。</p>
<h4 id="DP-二分"><a href="#DP-二分" class="headerlink" title="DP+二分"></a>DP+二分</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> dd[maxn], du[maxn], a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> c, n=<span class="number">0</span>, m, t=<span class="number">0</span>, len1=<span class="number">1</span>, len2=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c) == <span class="number">1</span>)</span><br><span class="line">    a[++n] = c;</span><br><span class="line">  dd[len1] = a[<span class="number">1</span>]; du[len2] = a[<span class="number">1</span>];</span><br><span class="line">  rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dd[len1] &gt;= a[i]) dd[++len1] = a[i];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> l=<span class="number">1</span>, r=len1, m;</span><br><span class="line">      <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        m = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dd[m] &lt; a[i]) r = m;</span><br><span class="line">        <span class="keyword">else</span> l = m+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      dd[l] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(du[len2] &lt; a[i]) du[++len2] = a[i];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> l=<span class="number">1</span>, r=len2, m;</span><br><span class="line">      <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= du[m]) r = m;</span><br><span class="line">        <span class="keyword">else</span> l = m+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      du[l] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>, len1, len2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DP</category>
        <category>线性结构上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>LIS</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>uva10003 Cutting Sticks DP剖分问题</title>
    <url>/2020/04/28/uva10003-Cutting-Sticks-DP%E5%89%96%E5%88%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-10003" target="_blank" rel="noopener">uva10003 Cutting Sticksb</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>You have to cut a wood stick into pieces. The most affordable company, The Analog Cutting Machinery, Inc. (ACM), charges money according to the length of the stick being cut. Their procedure of work requires that they only make one cut at a time.<a id="more"></a></p>
<p>It is easy to notice that different selections in the order of cutting can led to different prices. For example, consider a stick of length 10 meters that has to be cut at 2, 4 and 7 meters from one end. There are several choices. One can be cutting first at 2, then at 4, then at 7. This leads to a price of 10 + 8 + 6 = 24 because the first stick was of 10 meters, the resulting of 8 and the last one of 6. Another choice could be cutting at 4, then at 2, then at 7. This would lead to a price of 10 + 4 + 6 = 20, which is a better price.</p>
<p>Your boss trusts your computer abilities to find out the minimum cost for cutting a given stick.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input will consist of several input cases. The first line of each test case will contain a positive number <code>l</code> that represents the length of the stick to be cut. You can assume l &lt; 1000. The next line will contain the number <code>n</code> (n &lt; 50) of cuts to be made.</p>
<p>The next line consists of n positive numbers $c_i (0 &lt; c_i &lt; l)$ representing the places where the cuts have to be done, given in strictly increasing order.</p>
<p>An input case with l = 0 will represent the end of the input.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>You have to print the cost of the optimal solution of the cutting problem, that is the minimum cost of cutting the given stick. Format the output as shown below.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题意是给一根长度为<code>l</code>的木棒，并且给了<code>n</code>个需要切分的点，每切一次，切这刀之前的木棒的长度会算入 cost 中，求切完所有点之后最小的 cost。</p>
<p>例如，L=10，切割点为2, 4, 7。如果按照2, 4, 7的顺序，费用为10+8+6=24，如果按照4, 2, 7的顺序，费用为10+4+6=20。</p>
<p>这是一个剖分类型的问题，设<code>d[i][j]</code>为切 $i\sim j$ 这段范围的木棍的最小花费，尝试切割 $i+1\sim j-1$ 内的所有点 $k$，<strong>状态转移方程</strong>为 $d(i, j)={min(d(i, k) + d(k, j) | i&lt;k&lt;j)} + a(j) - a(i)$。显然这样 $i\sim j$ 就是一个最优子结构，最后答案就为<code>d[0][n]</code>。由于是三重循环，时间复杂度为 $O(n^3)$。</p>
<p>注意，DP 之前需要把<code>0</code>和<code>l</code>这两个端点添加进去。最外层的<code>i</code>需要逆序 DP，从<code>n-2</code>开始，<code>j</code>从<code>i+2</code>开始，因为 $i\sim i+1$ 不需要切分，并且要保证他们的<code>d</code>值为 0。这题还需要注意有<code>n=0</code>的情况。</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> l, n, c;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">"The minimum cutting is %d.\n"</span>, n == <span class="number">0</span> ? <span class="number">0</span> : l); <span class="keyword">continue</span>; &#125;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>; a[++n] = l; <span class="comment">// 添加两个端点</span></span><br><span class="line">    mset(d, <span class="number">0</span>, n);</span><br><span class="line">    per(i, n<span class="number">-2</span>, <span class="number">0</span>) &#123; <span class="comment">// i 从 n-2 开始逆序 DP</span></span><br><span class="line">      rep(j, i+<span class="number">2</span>, n) &#123; <span class="comment">// j 从 i+2 开始</span></span><br><span class="line">        d[i][j] = inf; <span class="comment">// 初始化为正无穷</span></span><br><span class="line">        rep(k, i+<span class="number">1</span>, j<span class="number">-1</span>)</span><br><span class="line">          d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">        d[i][j] += a[j] - a[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The minimum cutting is %d.\n"</span>, d[<span class="number">0</span>][n]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DP</category>
        <category>线性结构上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>DP 剖分问题</tag>
        <tag>uva</tag>
      </tags>
  </entry>
  <entry>
    <title>uva11400 Lighting System Design 线性结构DP</title>
    <url>/2020/05/01/uva11400-Lighting-System-Design-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84DP/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-11400" target="_blank" rel="noopener">uva11400 Lighting System Design</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>You are given the task to design a lighting system for a huge conference hall. After doing a lot of calculation and sketching, you have figured out the requirements for an energy-efficient design that can properly illuminate the entire hall. According to your design, you need lamps of n different power ratings. For some strange current regulation method, all the lamps need to be fed with the same amount of current. So, each category of lamp has a corresponding voltage rating.<a id="more"></a> Now, you know the number of lamps and cost of every single unit of lamp for each category. But the problem is, you are to buy equivalent voltage sources for all the lamp categories. You can buy a single voltage source for each category (Each source is capable of supplying to infinite number of lamps of its voltage rating.) and complete the design. But the accounts section of your company soon figures out that they might be able to reduce the total system cost by eliminating some of the voltage sources and replacing the lamps of that category with higher rating lamps. Certainly you can never replace a lamp by a lower rating lamp as some portion of the hall might not be illuminated then. You are more concerned about money-saving than energy-saving. Find the minimum possible cost to design the system.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>Each case in the input begins with n (1 ≤ n ≤ 1000), denoting the number of categories. Each of the following n lines describes a category. A category is described by 4 integers - V (1 ≤ V ≤ 132000), the voltage rating, K (1 ≤ K ≤ 1000), the cost of a voltage source of this rating, C (1 ≤ C ≤ 10), the cost of a lamp of this rating and L (1 ≤ L ≤ 100), the number of lamps required in this category. The input terminates with a test case where n = 0. This case should not be processed.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print the minimum possible cost to design the system.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>有一个照明系统需要用到n种灯，每种灯的电压为V，电源费用K，每个灯泡费用为C，需要该灯的数量为L。注意到，电压相同的灯泡只需要共享一个对应的电源即可，还有电压低的灯泡可以被电压高的灯泡替代。为了节约成本，你将设计一种系统，使之最便宜。</p>
<p>意思是这 n 种灯已经模拟了可以使用并且打算被安装，但是可以想办法节约成本。</p>
<p>由于只能是电压低的灯泡被电压高的灯泡替换，所以先按电压进行排序。<br>在替换的时候，对于某一种灯泡，显然是要么不换，要么全替换。（如果能替换一部分，那么说明替换的灯泡成本更低，那么肯定是全部替换）</p>
<p>这属于线性结构上的 DP，直接使用$i$来表示<strong>状态</strong>即可。<br>设s[i]为前i种灯泡的总数量(即L值之和)，<code>d[i]</code>以<code>i</code>为终点，表示为灯泡<code>1~i</code>的最小开销，则<strong>状态转移方程</strong>为<code>d[i] = min(d[i], d[j] + (s[i]-s[j])*c[i] + k[i]))</code>，表示前$j$个先用最优方案买，然后<code>j+1~i</code>个都用第$i$号的电源。答案为<code>d[n]</code>。</p>
<p>不能用外层循环只去替换内层的当前那种灯泡，假如用当前这个$i$替换掉了一个$j$的灯泡，这样就错了，前面的灯泡可能用的是他的电源，而你无法修改<code>d[j]</code>本身的值。</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lamp</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, k, c, l;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> lamp &amp;r) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; r.v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn], s[maxn]; <span class="comment">// d[i] 为灯泡 1~i 的最小开销；s[i] 为前 i 种灯泡的总个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    lamp &amp;u = a[i];</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] + u.l;</span><br><span class="line">    d[i] = s[i]*u.c + u.k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)</span><br><span class="line">      d[i] = <span class="built_in">min</span>(d[i], d[j] + (s[i]-s[j])*u.c + u.k); <span class="comment">// 表示之前j个先按j的最优方案买，然后之后的 j+1~i 都用 i 的灯泡</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n, v, k, c, l;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">      lamp &amp;u = a[i];</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u.v, &amp;u.k, &amp;u.c, &amp;u.l);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">    dp(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[n]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DP</category>
        <category>线性结构上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>uva</tag>
      </tags>
  </entry>
  <entry>
    <title>uva11584 Partitioning by Palindromes 线性结构DP</title>
    <url>/2020/04/06/uva11584-Partitioning-by-Palindromes-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84DP/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-11584" target="_blank" rel="noopener">uva11584 Partitioning by Palindromes</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>We say a sequence of char- acters is a palindrome if it is the same written forwards and backwards. For example, ‘racecar’ is a palindrome, but ‘fastcar’ is not.<br>A partition of a sequence of characters is a list of one or more disjoint non-empty groups of consecutive characters whose concatenation yields the initial sequence. For example, (‘race’, ‘car’) is a partition of ‘racecar’ into two groups.<a id="more"></a><br>Given a sequence of charac- ters, we can always create a par- tition of these characters such that each group in the partition is a palindrome! Given this ob- servation it is natural to ask: what is the minimum number of groups needed for a given string such that every group is a palin- drome?</p>
<p>For example:<br>• ‘racecar’ is already a palindrome, therefore it can be partitioned into one group.<br>• ‘fastcar’ does not con- tain any non-trivial palin- dromes, so it must be par- titioned as (‘f’, ‘a’, ‘s’, ‘t’, ‘c’, ‘a’, ‘r’).<br>• ‘aaadbccb’ can be parti- tioned as (‘aaa’, ‘d’, ‘bccb’).</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>Can you read upside-down?<br>Input begins with the number n of test cases. Each test case consists of a single line of between 1 and 1000 lowercase letters, with no whitespace within.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, output a line containing the minimum number of groups required to partition the input into groups of palindromes.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>给定一个字符串，判断最少有多少个回文串。<br>显然是线性结构上的 DP，设<strong>状态</strong><code>d[i]</code>为$1\sim i$的字符串中最少有多少个回文串，用两层$for$循环遍历，<strong>状态转移</strong>方程为<code>d[i] = min(d[i], d[j] + 1)</code>，表示$j+1\sim i$是一个回文串，然后决策。</p>
<p>每一次循环都需要判断回文串，所以先进行预处理，把所有回文串找出来。注意回文串有奇数长度和偶数长度的。<strong>时间复杂度</strong>包括预处理的$O(n^2)$和 dp 的$O(n^2)$。</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn]; <span class="comment">// d[i] 表示为 1~i 最少有多少个回文串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> s[maxn];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>); <span class="comment">// 空出0的位置，后面 dp 的时候就可以判断 a[1][i]</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++) &#123; <span class="comment">// 预处理，先将所有的回文串标记出来</span></span><br><span class="line">      a[i][i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> l=i<span class="number">-1</span>,r=i+<span class="number">1</span>,b1=<span class="number">1</span>,b2=<span class="number">1</span>; l+<span class="number">1</span>&gt;<span class="number">0</span> &amp;&amp; r&lt;=len; l--,r++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;<span class="number">0</span> &amp;&amp; s[l] != s[r]) b1 = <span class="number">0</span>; <span class="comment">// l~r 长度为奇数</span></span><br><span class="line">        a[l][r] = b1;</span><br><span class="line">        <span class="keyword">if</span>(s[l+<span class="number">1</span>] != s[r]) b2 = <span class="number">0</span>; <span class="comment">// l+1~r 长度为偶数</span></span><br><span class="line">        a[l+<span class="number">1</span>][r] = b2;</span><br><span class="line">        <span class="keyword">if</span>(!b1 &amp;&amp; !b2) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++) &#123;</span><br><span class="line">      d[i] = i; <span class="comment">// 初始化 d[i], 最多只有 i 个</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">        <span class="keyword">if</span>(a[j+<span class="number">1</span>][i]) d[i] = <span class="built_in">min</span>(d[i], d[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[len]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DP</category>
        <category>线性结构上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>uva</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title>P1280 尼克的任务 线性结构DP</title>
    <url>/2020/04/06/P1280-%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84DP/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1280" target="_blank" rel="noopener">P1280 尼克的任务</a></p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。<a id="more"></a></p>
<p>尼克的一个工作日为 n 分钟，从第 1 分钟开始到第 n 分钟结束。当尼克到达单位后他就开始干活，公司一共有 k 个任务需要完成。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 p 分钟开始，持续时间为 t 分钟，则该任务将在第 (p+t−1) 分钟结束。</p>
<p>写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入数据第一行含两个用空格隔开的整数 n 和 k。</p>
<p>接下来共有 k 行，每一行有两个用空格隔开的整数 p 和 t，表示该任务从第 p 分钟开始，持续时间为 t 分钟。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题意是给定一些任务，如何选取任务来获得最大的空闲时间<del>（还不赶快学了去摸鱼）</del>。由于是求空闲时间，所以可以将<code>1~n</code>的每一分钟都拆分成一个<strong>状态</strong>，设<code>d[i]</code> 为从时间 i 开始，最多能获得多少空闲时间。一开始可能会觉得如何判断当前选取的任务是否与之前选择的任务时间上有重叠不太好处理，我们可以对所有任务按开始时间排个序，然后对时间进行逆序遍历，仅当当前时间点有任务开始，才进行决策，<strong>状态转移</strong>方程为 $d(i) = max(d(i),~ d(i+T_i-1))$，若当前时间点没有任务开始，则 $d(i) = d(i+1)+1$，由于是按开始时间来排序并决策，所以不会影响到前面的小的时间点，所以保证了<strong>无后效性</strong>，并且不需要判断选取的两个任务是否有时间冲突（状态转移保证了不会有冲突）。这里用桶存储了某个时间点开始任务的个数，并且用一个<code>p</code>指针记录从哪开始访问任务。排序是 $O(nlog(n))$ 的时间复杂度，DP 的过程是线性的 $O(n + k)$，所以<strong>时间复杂度</strong>为 $O(nlog(n))$。</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> st, t;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;r) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> st &lt; r.st;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">node a[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn], c[maxn]; <span class="comment">// d: 以时间 i 开始，最多能获得多少空闲时间； c: 以 i 为开始时间的任务数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n, k, st, t;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">  rep(i, <span class="number">1</span>, k) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;st, &amp;t);</span><br><span class="line">    a[i].st = st; a[i].t = t;</span><br><span class="line">    c[st]++;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(a+<span class="number">1</span>, a+k+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> p = k; <span class="comment">// 记录从哪开始访问任务，1~p 为还未访问的任务</span></span><br><span class="line">  per(i, n, <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(c[i] == <span class="number">0</span>) d[i] = d[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      per(j, c[i], <span class="number">1</span>)</span><br><span class="line">        d[i] = <span class="built_in">max</span>(d[i], d[i + a[p--].t]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, d[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>线性结构上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>uva116 Unidirection TSP 多段图DP</title>
    <url>/2020/04/05/uva116-Unidirection-TSP-%E5%A4%9A%E6%AE%B5%E5%9B%BEDP/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-116" target="_blank" rel="noopener">uva116 Unidirectional TSP</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Problems that require minimum paths through some domain appear in many different areas of computer science. For example, one of the constraints in VLSI routing problems is minimizing wire length. The Traveling Salesperson Problem (TSP) — finding whether all the cities in a salesperson’s route can be visited exactly once with a specified limit on travel time — is one of the canonical examples of an NP-complete problem; solutions appear to require an inordinate amount of time to generate, but are simple to check.<a id="more"></a></p>
<p>This problem deals with finding a minimal path through a grid of points while traveling only from left to right.</p>
<p>Given an m × n matrix of integers, you are to write a program that computes a path of minimal weight. A path starts anywhere in column 1 (the first column) and consists of a sequence of steps terminating in column n (the last column). A step consists of traveling from column i to column i + 1 in an adjacent (horizontal or diagonal) row. The first and last rows (rows 1 and m) of a matrix are considered adjacent, i.e., the matrix “wraps” so that it represents a horizontal cylinder. Legal steps are illustrated on the right.</p>
<p>The weight of a path is the sum of the integers in each of the n cells of the matrix that are visited. For example, two slightly different 5×6 matrices are shown below (the only difference is the numbers in the bottom row).</p>
<p>The minimal path is illustrated for each matrix. Note that the path for the matrix on the right takes advantage of the adjacency property of the first and last rows.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input consists of a sequence of matrix specifications. Each matrix specification consists of the row and column dimensions in that order on a line followed by m · n integers where m is the row dimension and n is the column dimension. The integers appear in the input in row major order, i.e., the first n integers constitute the first row of the matrix, the second n integers constitute the second row and so on. The integers on a line will be separated from other integers by one or more spaces. Note: integers are not restricted to being positive.</p>
<p>There will be one or more matrix specifications in an input file. Input is terminated by end-of-file.</p>
<p>For each specification the number of rows will be between 1 and 10 inclusive; the number of columns will be between 1 and 100 inclusive. No path’s weight will exceed integer values representable using 30 bits.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Two lines should be output for each matrix specification in the input file, the first line represents a minimal-weight path, and the second line is the cost of a minimal path. The path consists of a sequence of n integers (separated by one or more spaces) representing the rows that constitute the minimal path. If there is more than one path of minimal weight the path that is lexicographically smallest should be output.</p>
<p>Note: Lexicographically means the natural order on sequences induced by the order on their elements.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>从矩阵第一列出发，到达最后一列，每一列是一个阶段，每个状态可以往右上、右、右下移动，所以一共有三个决策，求最短路径。</p>
<p>用$d(i, j)$表示<strong>状态</strong>，从第$i$行第$j$列<strong>出发</strong>，还需要走多远到达终点，<strong>状态转移</strong>方程为：$d(i, j)=min(d(i-1, j+1), d(i, j+1), d(i+1, j+1))$</p>
<p>在动态规划的过程中可以用一个$next$表将每个结点的最优后继存下来，到时候直接打印路径。</p>
<h4 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxm][maxn], d[maxm][maxn], next[maxm][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = INF, first; <span class="comment">// first 用于记录路径的开始（头）</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(j == n<span class="number">-1</span>) d[i][j] = a[i][j]; <span class="comment">// 边界</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> rows[] = &#123;i<span class="number">-1</span>, i, i+<span class="number">1</span>&#125;; <span class="comment">// 往下一列移动</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) rows[<span class="number">0</span>] = m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == m<span class="number">-1</span>) rows[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(rows, rows+<span class="number">3</span>); <span class="comment">// 按字典序排序</span></span><br><span class="line">        d[i][j] = INF; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">3</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">int</span> v = a[i][j] + d[rows[k]][j+<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span>(v &lt; d[i][j]) &#123;d[i][j] = v; next[i][j] = rows[k];&#125; <span class="comment">// 顺便记录下路径</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j == <span class="number">0</span> &amp;&amp; d[i][j] &lt; ans) &#123;ans = d[i][j]; first = i;&#125; <span class="comment">// 记录下答案路径的头</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, first+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>, i=next[first][<span class="number">0</span>]; j&lt;n; i=next[i][j], j++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, i+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> m, n;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n) == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">    dp(m, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>多阶段决策问题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>uva</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>uva12563 Jin Ge Jin Qu hao 01背包+滚动数组</title>
    <url>/2020/04/17/uva12563-Jin-Ge-Jin-Qu-hao-01%E8%83%8C%E5%8C%85-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-12563#author=0" target="_blank" rel="noopener">uva12563 Jin Ge Jin Qu hao</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>(If you smiled when you see the title, this problem is for you ^_^)</p>
<p>For those who don’t know KTV, see: <a href="http://en.wikipedia.org/wiki/Karaoke_box" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Karaoke_box</a></p>
<p>There is one very popular song called Jin Ge Jin Qu(). It is a mix of 37 songs, and is extremely long (11 minutes and 18 seconds) — I know that there are Jin Ge Jin Qu II and III, and some other unofficial versions. But in this problem please forget about them.<a id="more"></a></p>
<p>Why is it popular? Suppose you have only 15 seconds left (until your time is up), then you should select another song as soon as possible, because the KTV will not crudely stop a song before it ends (people will get frustrated if it does so!). If you select a 2-minute song, you actually get 105 extra seconds! ….and if you select Jin Ge Jin Qu, you’ll get 663 extra seconds!!!</p>
<p>Now that you still have some time, but you’d like to make a plan now. You should stick to the following rules:</p>
<p>• Don’t sing a song more than once (including Jin Ge Jin Qu).<br>• For each song of length t, either sing it for exactly t seconds, or don’t sing it at all.<br>• When a song is finished, always immediately start a new song.</p>
<p>Your goal is simple: sing as many songs as possible, and leave KTV as late as possible (since we have rule 3, this also maximizes the total lengths of all songs we sing) when there are ties.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line contains the number of test cases T (T ≤ 100). Each test case begins with two positive integers n, t (1 ≤ n ≤ 50, 1 ≤ t ≤ $10^9$), the number of candidate songs (BESIDES Jin Ge Jin Qu) and the time left (in seconds). The next line contains n positive integers, the lengths of each song, in seconds. Each length will be less than 3 minutes — I know that most songs are longer than 3 minutes. But don’t forget that we could manually “cut” the song after we feel satisfied, before the song ends. So here “length” actually means “length of the part that we want to sing”.</p>
<p>It is guaranteed that the sum of lengths of all songs (including Jin Ge Jin Qu) will be strictly larger than t.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print the maximum number of songs (including Jin Ge Jin Qu), and the total lengths of songs that you’ll sing.</p>
<p>Explanation:</p>
<p>In the first example, the best we can do is to sing the third song (80 seconds), then Jin Ge Jin Qu for another 678 seconds.</p>
<p>In the second example, we sing the first two (30+69=99 seconds). Then we still have one second left, so we can sing Jin Ge Jin Qu for extra 678 seconds. However, if we sing the first and third song instead (30+70=100 seconds), the time is already up (since we only have 100 seconds in total), so we can’t sing Jin Ge Jin Qu anymore!</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>在$t$秒内从$n$首歌中选取尽可能多的曲目数量，典型的01背包。由于最后需要留时间来唱劲歌金曲，所以不能把所有的$t$都用完，至少需要留1秒。最后答案记得加上劲歌金曲。</p>
<p>注意虽然题目给的 $t&lt;=10^9$，但是由于每首歌不超过3分钟，最多50首歌，所以实际上 $t$ 不会超过$180*n + 678$。</p>
<p>设<code>d[i][j]</code>为<code>1~i</code>首曲子，总时间为<code>j</code>秒，最多能唱多少首曲子。双重循环遍历，外层遍历歌曲，内层遍历时间，<strong>状态转移</strong>方程为 $d(i, j) = \{max(d(i, j), d(i-1, j-v_i) + 1 | j&gt;v_i\}$。</p>
<p>特别注意，最后答案需要求总的时长，所以不能单纯使用01背包的模板，因为无法知道总共花费的时间，01背包模板的答案存储在<code>d[1][C]</code>或者<code>d[n][C]</code>，但是这个答案的总时长很可能是不对的，因为不要用到这么多时间。所以这里要特殊处理，将初始值全都弄成一个很小的负值，然后将 <code>d[0]</code>设为0，意思是正好将时间用完的才会记录成正数，否则如果用完还有剩，虽然会进行+1操作，但是依旧是很小的负值。</p>
<h4 id="01背包-滚动数组"><a href="#01背包-滚动数组" class="headerlink" title="01背包+滚动数组"></a>01背包+滚动数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxm]; <span class="comment">// d 是歌曲数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> T, n, t, v, ans;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> kase=<span class="number">1</span>; kase&lt;=T; kase++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;t);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x8f</span>, <span class="keyword">sizeof</span>(d)); <span class="comment">// 初始化成一个很小的负数，对于那些唱完某首歌还有时间剩的来说，+1了也依旧是很小的负数</span></span><br><span class="line">    d[<span class="number">0</span>] = ans = <span class="number">0</span>; <span class="comment">// 将d[0]标记成0，ans 用于记录最大的歌曲数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=t<span class="number">-1</span>; j&gt;=v; j--) &#123;</span><br><span class="line">        d[j] = <span class="built_in">max</span>(d[j], d[j-v] + <span class="number">1</span>); <span class="comment">// 采用滚动数组，减少存储空间，需要 j 反向遍历</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, d[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=t<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) <span class="keyword">if</span>(d[j] == ans) &#123; <span class="comment">// 直接用 ans 来找出总时长</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Case %d: %d %d\n"</span>, kase, ans + <span class="number">1</span>, j + <span class="number">678</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>多阶段决策问题</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>uva</tag>
        <tag>01背包</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title>uva1347 Tour 记忆化搜索和递推</title>
    <url>/2020/04/03/uva1347-Tour-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%92%8C%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-1347" target="_blank" rel="noopener">uva1347 Tour</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>John Doe, a skilled pilot, enjoys traveling. While on vacation, he rents a small plane and starts visiting beautiful places. To save money, John must determine the shortest closed tour that connects his destinations. Each destination is represented by a point in the plane pi =&lt; xi,yi &gt;. John uses the following strategy: he starts from the leftmost point, then he goes strictly left to right to the rightmost point, and then he goes strictly right back to the starting point. It is known that the points have distinct x-coordinates.<a id="more"></a></p>
<p>Write a program that, given a set of n points in the plane, computes the shortest closed tour that connects the points according to John’s strategy.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The program input is from a text file. Each data set in the file stands for a particular set of points. For each set of points the data set contains the number of points, and the point coordinates in ascending order of the x coordinate. White spaces can occur freely in input. The input data are correct.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each set of data, your program should print the result to the standard output from the beginning of a line. The tour length, a floating-point number with two fractional digits, represents the result.</p>
<p>Note: An input/output sample is in the table below. Here there are two data sets. The first one contains 3 points specified by their x and y coordinates. The second point, for example, has the x coordinate 2, and the y coordinate 3. The result for each data set is the tour length, (6.47 for the first data set in the given example).</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目是需要找一条从起点到终点再回到起点的最短路，且除了起点和终点外每个点都仅经过一次。可以转化成两个人同时从起点出发，最后都到达终点的最短路。</p>
<p>用<code>i</code>和<code>j</code>当前所在点作为<strong>状态</strong>，然后定义<code>dp(i, j)</code>为<strong>从当前状态出发</strong>，还需要多远才能到达终点，且<code>0~max(i, j)</code>都已经走过了。由于需要保证每个都需要且仅经过一次，所以设置每次只让<code>i</code>或者<code>j</code>往前走一步，为了便于处理，设置<code>i&gt;j</code>。当<code>i</code>往前走一步则变为<code>(i+1, j)</code>；当<code>j</code>往前走一步则变为<code>(i, i+1)</code>，由于<code>i&gt;j</code>，所以变成<code>(i+1, i)</code>。每个状态的<strong>决策</strong>是两个，时间复杂度为$O(n^2)$。</p>
<p>这样即可推出<strong>状态转移方程</strong>：<code>dp(i, j) = min(dp(i+1, j) + dis(i, i+1), dp(i+1, i) + dis(j, i+1))</code>。<em>（dis 为两点之间的距离）</em></p>
<p>分别用两种方法实现：记忆化搜索、递推</p>
<h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], n;</span><br><span class="line"><span class="keyword">double</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>((x[i]-x[j]), <span class="number">2</span>) + <span class="built_in">pow</span>((y[i]-y[j]), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i == n<span class="number">-1</span>) <span class="keyword">return</span> d[i][j] = dis(i, j); <span class="comment">// 终止条件，返回 j 到 n-1 的距离即可</span></span><br><span class="line">  <span class="keyword">if</span>(d[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[i][j]; <span class="comment">// 已经搜索过，直接返回</span></span><br><span class="line">  <span class="keyword">return</span> d[i][j] = <span class="built_in">min</span>(dis(i, i+<span class="number">1</span>) + dp(i+<span class="number">1</span>, j), dis(j, i+<span class="number">1</span>) + dp(i+<span class="number">1</span>, i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, dp(<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 答案为起始点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], n;</span><br><span class="line"><span class="keyword">double</span> dis[maxn][maxn], dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 提前计算好每两点的距离</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;=n; j++)</span><br><span class="line">        dis[i][j] = dis[j][i] = <span class="built_in">sqrt</span>((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">2</span>; i--) <span class="comment">// dp(i, j) 定义为从该点出发，还需要走多远；倒着递推</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++) <span class="comment">// dp(i, j) == dp(j, i)，始终令 i &gt; j，便于处理</span></span><br><span class="line">        <span class="keyword">if</span>(i == n<span class="number">-1</span>) dp[i][j] = dis[j][n] + dis[i][n]; <span class="comment">// 边界</span></span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j] + dis[i][i+<span class="number">1</span>], dp[i+<span class="number">1</span>][i] + dis[j][i+<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, dp[<span class="number">2</span>][<span class="number">1</span>] + dis[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 起始点为答案，即 dp[1][1] = dp[2][1] + dis[1][2]</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>DAG上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>uva</tag>
        <tag>递推</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>各操作系统之间进行文件传输 SCP、WinSCP、rsync</title>
    <url>/2020/04/12/%E5%90%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<h2 id="SCP"><a href="#SCP" class="headerlink" title="SCP"></a>SCP</h2><p>scp 命令用于 Linux / Unix 之间复制文件和目录，是基于 ssh 登陆进行安全的远程文件拷贝命令。<a id="more"></a></p>
<h3 id="本地-gt-远程"><a href="#本地-gt-远程" class="headerlink" title="本地 -&gt; 远程"></a>本地 -&gt; 远程</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行后需要输入对应用户的密码，指定了远程的目录路径</span></span><br><span class="line">scp local_file remote_username@remote_ip:remote_file</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行后需要输入对应用户的密码，指定了远程的路径和文件名</span></span><br><span class="line">scp local_file remote_ip:remote_folder</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行后需要输入用户名和密码，指定了远程的目录路径</span></span><br><span class="line">scp local_file remote_ip:remote_file</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行后需要输入用户名和密码，，指定了远程的路径和文件名</span></span><br></pre></td></tr></table></figure>
<h3 id="远程-gt-本地"><a href="#远程-gt-本地" class="headerlink" title="远程 -&gt; 本地"></a>远程 -&gt; 本地</h3><p>和上面的类似，只是调换了本地参数和远程参数的位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp remote_username@remote_ip:remote_folder local_file</span><br><span class="line">scp remote_username@remote_ip:remote_file local_file</span><br><span class="line">scp remote_ip:remote_folder local_file</span><br><span class="line">scp remote_ip:remote_file local_file</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="WinSCP"><a href="#WinSCP" class="headerlink" title="WinSCP"></a>WinSCP</h2><p><a href="https://winscp.net/eng/download.php" target="_blank" rel="noopener">WinSCP Download</a></p>
<p>WinSCP 是一款开源的 SFTP 客户端，WinSCP 除了SFTP，还支持SSH、SCP。</p>
<p>WinSCP 有图形用户界面，直接拖拽就可以在 Windows 与 Linux 之间传输文件。</p>
<hr>
<h2 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h2><p><strong>rsync</strong>是Unix下的一款应用软件，它能<strong>同步</strong>更新两处计算机的文件与目录，并适当利用<strong>差分编码</strong>以减少数据传输量。rsync中的一项同类软件不常见的重要特性是每个目标的镜像只需发送一次。rsync可以拷贝／显示目录内容，以及拷贝文件，并可选压缩以及递归拷贝。</p>
<p>在常驻模式（daemon mode）下，rsync 默认监听TCP端口873，以原生 rsync 传输协议或者透过远程 shell 如 RSH 或者 SSH 提供文件。所以 rsync 支持<strong>断点续传</strong>。</p>
<p>rsync的撰写是用来取代rcp与SCP。rsync最早期程序的其中之一是用来实现透过rsync/ssh与标准Unix账号，从多重Unix客户端镜像或者备份到中央Unix服务器。与如Cron类似的调度应用程序配合，任何人皆可调度介于多台电脑与中央服务器间自动加密过、基于rsync的<strong>镜像备份</strong>。</p>
<blockquote>
<p>语法</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync [OPTION]... SRC [SRC]... DEST</span><br><span class="line">rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST</span><br><span class="line">rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST</span><br><span class="line">rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST</span><br><span class="line">rsync [OPTION]... SRC</span><br><span class="line">rsync [OPTION]... [USER@]HOST:SRC [DEST]</span><br><span class="line">rsync [OPTION]... [USER@]HOST::SRC [DEST]</span><br><span class="line">rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]</span><br></pre></td></tr></table></figure>
<p>rsync有六种不同的工作模式：</p>
<ol>
<li><p>拷贝本地文件。</p>
<p>当SRC和DES路径信息都不包含有单个冒号”<code>:</code>“分隔符时就启动这种工作模式。如：<code>rsync -a /data /backup</code></p>
</li>
<li><p>使用一个远程shell程序（如rsh、ssh）来实现将本地机器的内容拷贝到远程机器。</p>
<p>当DST路径地址包含单个冒号”<code>:</code>“分隔符时启动该模式。如：<code>rsync -avz *.c foo:src</code></p>
</li>
<li><p>使用一个远程shell程序（如rsh、ssh）来实现将远程机器的内容拷贝到本地机器。</p>
<p>当SRC地址路径包含单个冒号”<code>:</code>“分隔符时启动该模式。如：<code>rsync -avz foo:src/bar /data</code></p>
</li>
<li><p>从远程rsync服务器中拷贝文件到本地机。</p>
<p>当SRC路径信息包含”<code>::</code>“分隔符时启动该模式。如：<code>rsync -av root@192.168.0.1::path /databack</code></p>
</li>
<li><p>从本地机器拷贝文件到远程rsync服务器中。</p>
<p>当DST路径信息包含”<code>::</code>“分隔符时启动该模式。如：<code>rsync -av /databack root@192.168.0.1::path</code></p>
</li>
<li><p>列远程机的文件列表。</p>
<p>这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：<code>rsync -v rsync://192.168.0.1/path</code></p>
</li>
</ol>
<blockquote>
<p>选项</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-v, --verbose          详细模式输出。</span><br><span class="line">-q, --quiet            精简输出模式。</span><br><span class="line">-c, --checksum         打开校验开关，强制对文件传输进行校验。</span><br><span class="line">-a, --archive          归档模式，表示以递归方式传输文件，并保持所有文件属性，等于 -rlptgoD。</span><br><span class="line">-r, --recursive        对子目录以递归模式处理。</span><br><span class="line">-R, --relative         使用相对路径信息。</span><br><span class="line">-b, --backup           创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为 ~filename。可以使用 --suffix 选项来指定不同的备份文件前缀。</span><br><span class="line">--backup-dir           将备份文件（~filename）存放在在目录下。</span><br><span class="line">-suffix&#x3D;SUFFIX         定义备份文件前缀。</span><br><span class="line">-u, --update           仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件。（不覆盖更新的文件。）</span><br><span class="line">-l, --links            保留软链结。</span><br><span class="line">-L, --copy-links       想对待常规文件一样处理软链结。</span><br><span class="line">--copy-unsafe-links    仅仅拷贝指向 SRC 路径目录树以外的链结。</span><br><span class="line">--safe-links           忽略指向 SRC 路径目录树以外的链结。</span><br><span class="line">-H, --hard-links       保留硬链结。</span><br><span class="line">-p, --perms            保持文件权限。</span><br><span class="line">-o, --owner            保持文件属主信息。</span><br><span class="line">-g, --group            保持文件属组信息。</span><br><span class="line">-D, --devices          保持设备文件信息。</span><br><span class="line">-t, --times            保持文件时间信息。</span><br><span class="line">-S, --sparse           对稀疏文件进行特殊处理以节省 DST 的空间。</span><br><span class="line">-n, --dry-run          显示哪些文件将被传输（新增、修改和删除）。</span><br><span class="line">-W, --whole-file       拷贝文件，不进行增量检测。</span><br><span class="line">-x, --one-file-system  不要跨越文件系统边界。</span><br><span class="line">-B, --block-size&#x3D;SIZE  检验算法使用的块尺寸，默认是 700 字节。</span><br><span class="line">-e, --rsh&#x3D;COMMAND      指定使用 rsh, ssh 方式进行数据同步。</span><br><span class="line">--rsync-path&#x3D;PATH      指定远程服务器上的 rsync 命令所在路径信息。</span><br><span class="line">-C, --cvs-exclude      使用和 CVS 一样的方法自动忽略文件，用来排除那些不希望传输的文件。</span><br><span class="line">--existing             仅仅更新那些已经存在于 DST 的文件，而不备份那些新创建的文件。</span><br><span class="line">--delete               删除那些 DST 中 SRC 没有的文件。</span><br><span class="line">--delete-excluded      同样删除接收端那些被该选项指定排除的文件。</span><br><span class="line">--delete-after         传输结束以后再删除。</span><br><span class="line">--ignore-errors        即使出现 IO 错误也进行删除。</span><br><span class="line">--max-delete&#x3D;NUM       最多删除 NUM 个文件。</span><br><span class="line">--partial              保留那些因故没有完全传输的文件，以便实现断点续传。</span><br><span class="line">--force                强制删除目录，即使不为空。</span><br><span class="line">--numeric-ids          不将数字的用户和组 ID 匹配为用户名和组名。</span><br><span class="line">--timeout&#x3D;TIME         IP 超时时间，单位为秒。</span><br><span class="line">-I, --ignore-times     不跳过那些有同样的时间和长度的文件。</span><br><span class="line">--size-only            当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。</span><br><span class="line">--modify-window&#x3D;NUM    决定文件是否时间相同时使用的时间戳窗口，默认为 0。</span><br><span class="line">-T --temp-dir&#x3D;DIR      在 DIR 中创建临时文件。</span><br><span class="line">--compare-dest&#x3D;DIR     同样比较 DIR 中的文件来决定是否需要备份。</span><br><span class="line">--progress             显示传输过程。</span><br><span class="line">-P                     等同于 -partial -progress。</span><br><span class="line">-z, --compress         对备份的文件在传输时进行压缩处理。</span><br><span class="line">--exclude&#x3D;PATTERN      指定排除不需要传输的文件模式。</span><br><span class="line">--include&#x3D;PATTERN      指定不排除而需要传输的文件模式。</span><br><span class="line">--exclude-from&#x3D;FILE    排除 FILE 中指定模式的文件。</span><br><span class="line">--include-from&#x3D;FILE    不排除 FILE 指定模式匹配的文件。</span><br><span class="line">--version              打印版本信息。</span><br><span class="line">--address              绑定到特定的地址。</span><br><span class="line">--config&#x3D;FILE          指定其他的配置文件，不使用默认的 rsyncd.conf 文件。</span><br><span class="line">--port&#x3D;PORT            指定其他的 rsync 服务端口。</span><br><span class="line">--blocking-io          对远程 shell 使用阻塞 IO。</span><br><span class="line">--stats                给出某些文件的传输状态。</span><br><span class="line">--log-format&#x3D;formAT    指定日志文件格式。</span><br><span class="line">--password-file&#x3D;FILE   从 FILE 中得到密码。</span><br><span class="line">--bwlimit&#x3D;KBPS         限制 I&#x2F;O 带宽，KBytes per second。</span><br><span class="line">-h, --help             显示帮助信息。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件传输</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列 LCS -- DP/转LIS求解</title>
    <url>/2020/04/27/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-LCS-DP-%E8%BD%ACLIS%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="最长公共子序列问题-LCS"><a href="#最长公共子序列问题-LCS" class="headerlink" title="最长公共子序列问题(LCS)"></a>最长公共子序列问题(LCS)</h2><p>给两个序列A和B，求长度最大的公共子序列。例如1, 5, 2, 6, 8, 7和2, 3, 5, 6, 9, 8, 4的最长公共子序列为5, 6, 8(另一个解是2, 6, 8)。</p>
<p><a href="https://www.luogu.com.cn/problem/P1439" target="_blank" rel="noopener">洛谷 P1439 【模板】最长公共子序列</a><a id="more"></a></p>
<h3 id="1-二维DP-滚动数组"><a href="#1-二维DP-滚动数组" class="headerlink" title="1. 二维DP+滚动数组"></a>1. 二维DP+滚动数组</h3><p>对于这类问题，可以设<code>d[i][j]</code>为 A 中<code>1~i</code>和 B 中<code>1~j</code>的序列的最长公共子序列的长度，双重循环，每次都遍历一遍 B 的所有数，当<code>A[i]=B[j]</code>时，<code>d[i][j] = d[i-1][j-1]+1</code>；否则，<code>d[i][j] = max(d[i-1][j], d[i][j-1])</code>。<br>由于是线性结构，这个可以用滚动数组优化存储空间。而时间复杂度是 $O(n^2)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], d[<span class="number">2</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">  <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == b[j]) d[t][j] = d[t^<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> d[t][j] = <span class="built_in">max</span>(d[t^<span class="number">1</span>][j], d[t][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    t ^= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, d[t^<span class="number">1</span>][n]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-转-LIS-求解"><a href="#2-转-LIS-求解" class="headerlink" title="2. 转 LIS 求解"></a>2. 转 LIS 求解</h3><p>对于 LCS，可以根据 A 序列的值重新映射一下 B 序列的值，将 A 序列变成一个递增的序列，求 LCS 就转变成一个在 B 上求 LIS 的问题。</p>
<p>这么说可能很难理解，来举个例子。<br>例如有 $A: 1, 3, 2, 5, 4$，$B: 1, 2, 3, 4, 5$，可以将其重新标一下号：</p>
<script type="math/tex; mode=display">
A: a, b, c, d, e \\
B: a, c, b, e, d</script><p>显然对于这样两个序列来说，由于 A 的序列是递增的，那么 A 和 B 的 LCS 在 B 中必然是递增的，这就变成了一个在 B 上求 LIS 的问题了。</p>
<p>先处理映射，然后直接套用 LIS 的算法即可，使用 LIS 的 <strong>DP+二分</strong>的算法，时间复杂度为 $O(nlog(n))$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn], d[maxn], a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> n, u, len = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">  rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">    f[u] = i; <span class="comment">// 重新映射 A 的值</span></span><br><span class="line">  &#125;</span><br><span class="line">  rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;u);</span><br><span class="line">    a[i] = f[u]; <span class="comment">// 重新映射 B 的值</span></span><br><span class="line">  &#125;</span><br><span class="line">  d[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">  rep(i, <span class="number">2</span>, n) &#123; <span class="comment">// LIS DP+二分求解</span></span><br><span class="line">    <span class="keyword">if</span>(a[i] &gt; d[len]) &#123; d[++len] = a[i]; <span class="keyword">continue</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>, r=len, m;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">      m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(a[i] &lt; d[m]) r = m;</span><br><span class="line">      <span class="keyword">else</span> l = m+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d[l] = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>线性结构上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>LIS</tag>
        <tag>洛谷</tag>
        <tag>滚动数组</tag>
        <tag>LCS</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>uva1626 Brackets sequence 线性结构DP</title>
    <url>/2020/04/29/uva1626-Brackets-sequence-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84DP/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-1626" target="_blank" rel="noopener">uva1626 Brackets sequence</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>Let us define a regular brackets sequence in the following way:</p>
<ol>
<li>Empty sequence is a regular sequence.</li>
<li>If S is a regular sequence, then (S) and [S] are both regular sequences. 3. If A and B are regular sequences, then AB is a regular sequence.<a id="more"></a><br>For example, all of the following sequences of characters are regular brackets sequences: (), [], (()), ([]), ()[], ()[()]<br>And all of the following character sequences are not: (, [, ), )(, ([)], ([]<br>Some sequence of characters ‘(’, ‘)’, ‘[’, and ‘]’ is given. You are to find the shortest possible regular brackets sequence, that contains the given character sequence as a subsequence. Here, a string a1a2 …an is called a subsequence of the string $b_1,b_2, …,b_m$, if there exist such indices $1 ≤ i_1 &lt; i_2 &lt; …&lt;i_n ≤m$, that $a_j =b_{ij}$ for all $1≤j≤n$.</li>
</ol>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.</p>
<p>The input file contains at most 100 brackets (characters ‘(’, ‘)’, ‘[’ and ‘]’) that are situated on a single line without any other characters among them.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line.<br>Write to the output file a single line that contains some regular brackets sequence that has the minimal possible length and contains the given sequence as a subsequence.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题意是给一个括号的序列，求最少要插入多少个括号才能使得这个序列符合正规的括号序列，并且打印出一个解。</p>
<p>设<code>d[i][j]</code>为<code>i~j</code>这个序列最少要插入多少个括号。</p>
<ul>
<li>如果当前序列 S 形如(S′)或者[S′]，则转移到d(S′)。$d(i, j) = \{min(d(i, j), d(i+1, j-1)) | match(i, j)\}$</li>
<li>如果S至少有两个字符，则可以分成AB，转移到d(A)+d(B)。$d(i, j) = \{min(d(i, j), d(i, k) + d(k+1, j)) | i\leq k&lt;j\}$</li>
</ul>
<p>这显然也是一个最优子结构问题，利用三重循环找出当前最优的解，时间复杂度为 $O(n^3)$，由于数据量比较小，所以不用担心超时。</p>
<p>这题打印解比较麻烦，需要重新类似 DP 一样找一遍，由于已经知道最少情况的答案，所以采用递归打印，一旦发现满足答案中的子序列，在打印之后之间返回，可以减去很多枝。</p>
<p>注意，答案中包含空串，不能用 scanf。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> l, <span class="keyword">char</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((l == <span class="string">'('</span> &amp;&amp; r == <span class="string">')'</span>) || (l == <span class="string">'['</span> &amp;&amp; r == <span class="string">']'</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i &gt; j) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">'('</span> || s[i] == <span class="string">')'</span>) <span class="built_in">printf</span>(<span class="string">"()"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"[]"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = d[i][j];</span><br><span class="line">  <span class="keyword">if</span>(match(s[i], s[j]) &amp;&amp; d[i+<span class="number">1</span>][j<span class="number">-1</span>] == ans) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[i]); <span class="built_in">print</span>(i+<span class="number">1</span>, j<span class="number">-1</span>); <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[j]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  rep(k, i, j<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span>(d[i][k] + d[k+<span class="number">1</span>][j] == ans) &#123;</span><br><span class="line">      <span class="built_in">print</span>(i, k); <span class="built_in">print</span>(k+<span class="number">1</span>, j);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t); getchar();</span><br><span class="line">  <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">      c = getchar();</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">'\n'</span>) <span class="keyword">break</span>;</span><br><span class="line">      s[++n] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">      d[i + <span class="number">1</span>][i] = <span class="number">0</span>; <span class="comment">// 如果这是两个相邻且匹配的括号，后面判断匹配的时候，d[i+1][j-1] = d[i+1][i] = 0</span></span><br><span class="line">      d[i][i] = <span class="number">1</span>; <span class="comment">// 初始化成每一个括号可以增加一个括号来匹配自己</span></span><br><span class="line">    &#125;</span><br><span class="line">    per(i, n<span class="number">-1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">      rep(j, i+<span class="number">1</span>, n) &#123;</span><br><span class="line">        d[i][j] = n;</span><br><span class="line">        <span class="keyword">if</span>(match(s[i], s[j])) d[i][j] = <span class="built_in">min</span>(d[i][j], d[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">        rep(k, i, j<span class="number">-1</span>)</span><br><span class="line">          d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k+<span class="number">1</span>][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(t) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DP</category>
        <category>线性结构上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>uva</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列 LIS -- DP/DP+二分</title>
    <url>/2020/04/27/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-LIS-DP-DP-%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<h2 id="最长上升子序列问题-LIS"><a href="#最长上升子序列问题-LIS" class="headerlink" title="最长上升子序列问题(LIS)"></a>最长上升子序列问题(LIS)</h2><p>给定<code>n</code>个整数 $A_1, A_2,\ldots ,A_n$，按从左到右的顺序选出尽量多的整数，组成一个上升子序列(子序列可以理解为：删除0个或多个数，其他数的顺序不变)。例如序列1, 6, 2, 3, 7, 5，可以选出上升子序列1, 2, 3, 5，也可以选出1, 6, 7，但前者更长。<a id="more"></a></p>
<p><a href="https://vjudge.net/problem/OpenJ_Bailian-2757" target="_blank" rel="noopener">vjudge 最长上升子序列</a><br><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">LeetCode 300. 最长上升子序列</a></p>
<h3 id="1-直接DP"><a href="#1-直接DP" class="headerlink" title="1. 直接DP"></a>1. 直接DP</h3><p>我们可以将<strong><code>d[i]</code></strong>定义为以<code>i</code>为结尾的序列的上升子序列的长度。每次读一个新的数，然后去遍历之前的所有数，找比这个数小的，<strong>状态转移</strong>方程为 $d(i)=\{ max(d(i), d(j)+1) | j&lt;i, A_j&lt;A_i \}$。<br>时间复杂度：$O(n^2)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn], a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;syn</span><br><span class="line">  <span class="keyword">int</span> n, ans=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    d[i] = <span class="number">1</span>;</span><br><span class="line">    rep(j, <span class="number">1</span>, i<span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">if</span>(a[i] &gt; a[j]) d[i] = <span class="built_in">max</span>(d[i], d[j] + <span class="number">1</span>);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-DP-二分"><a href="#2-DP-二分" class="headerlink" title="2. DP+二分"></a>2. DP+二分</h3><p>上面那种方法由于每次都需要全遍历一遍之前的数，对于<code>N</code>为 $10^4$ 以上的数据是过不了的，需要进行优化。既然是求上升的子序列，上升本身就是一种有序的序列，而上面的方法需要每次遍历找比他小的数，那就看看能不能在找的时候优化成使用二分进行查找，这样可以将复杂度降到 $O(nlog(n))$。</p>
<p>我们需要重新定义一下<code>d[i]</code>，将<code>d[i]</code>的<code>i</code>定义为子序列的长度，而<strong><code>d[i]</code></strong> 存放子序列长度为<code>i</code>的序列的末尾的数，如果相同长度的子序列，则看谁的尾数最小就记录谁。这样定义的话，则数组<code>d</code>必然是有序的。</p>
<p>设置一个变量<code>len</code>记录当前最长的子序列的长度。每次读一个新数的时候，查看长度为<code>len</code>的子序列的尾数是否小于当前的数，如果小于，则说明可以接到他这个子序列上；如果大于，则二分查找，直到找到一个<strong>刚好比他大</strong>的数（如果是不下降子序列则可以等于），也就是找<strong>下界</strong>。这里注意，为什么是找刚好比他大的数呢？因为当找到一个刚好小于他的数，他肯定能拼接到这个序列上，并且要在这个序列的长度上<code>+1</code>，<code>+1</code>这意味着需要和后面的那个刚好比他大进行比较，由于上面定义的时候是选择更小的那个，所以那个刚好比他大的数肯定会被替换。<br>时间复杂度：$O(nlog(n))$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn], a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;F syn</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  rep(i, <span class="number">1</span>, n) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  d[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">1</span>; <span class="comment">// 表示当前最长的子序列的长度</span></span><br><span class="line">  rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] &gt; d[len]) &#123; d[++len] = a[i]; <span class="keyword">continue</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>, r=len, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123; <span class="comment">// 二分</span></span><br><span class="line">      mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &lt;= d[mid]) r = mid; <span class="comment">// 如果小于这个尾数则继续找，直到找到一个刚好比他大的尾数</span></span><br><span class="line">      <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d[l] = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的二分还可以使用 STL 的 <code>lower_bound</code>，这个函数就是求下界的。将二分那一段改成下面这个即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pos = lower_bound(d+<span class="number">1</span>, d+len+<span class="number">1</span>, i) - d;</span><br><span class="line">d[pos] = a[i];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DP</category>
        <category>线性结构上的DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>LeetCode</tag>
        <tag>LIS</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>添加 snippets 代码模板片段</title>
    <url>/2020/04/16/%E6%B7%BB%E5%8A%A0-snippets-%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E7%89%87%E6%AE%B5/</url>
    <content><![CDATA[<p>先附上我的代码模板<a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> syn ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F freopen(<span class="meta-string">"../in.txt"</span>, <span class="meta-string">"r"</span>, stdin); freopen(<span class="meta-string">"../out.txt"</span>, <span class="meta-string">"w"</span>, stdout);</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> si set<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) (int)(x.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(v) (v).begin(),(v).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i=(a);i&lt;=(b);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,b) for(int i=(a);i&gt;=(b);--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">mset</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">val</span>, <span class="title">int</span> <span class="title">n</span>) &#123;</span> <span class="built_in">memset</span>(a, val, n * <span class="keyword">sizeof</span>(T)); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps (1e-8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1&lt;&lt;30)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="vscode-添加-snippets"><a href="#vscode-添加-snippets" class="headerlink" title="vscode 添加 snippets"></a>vscode 添加 snippets</h3><p>使用快捷键<code>cmd+shift+p</code>，然后输入<code>snippets</code><br><img src="http://q9j7cl8us.bkt.clouddn.com/img/Screen Shot 2020-04-28 at 10.17.14 PM.png?imageslim" style="zoom: 43%;" /><br>选择这个，然后会出现如下图所示的选项<br><img src="http://q9j7cl8us.bkt.clouddn.com/img/Screen Shot 2020-04-28 at 10.17.38 PM.png?imageslim" style="zoom:33%;" /><br>选择 cpp，这样就只会对 cpp 文件起作用，选择 New Global Snippets File 则全局都会生效</p>
<ul>
<li>最开始的一对双引号表示代码片段的名字</li>
<li><code>prefix</code>表示触发代码片段的快捷码</li>
<li><code>body</code>里面存放代码片段，多行的话需要用<code>[]</code>括起来整个代码片段，然后里面每一对引号表示一行，有些字符需要用<code>\</code>进行转义</li>
<li><code>description</code>对应代码片段描述</li>
</ul>
<p>建议直接使用这个网站<a href="https://snippet-generator.app/?description=&amp;tabtrigger=&amp;snippet=&amp;mode=vscode" target="_blank" rel="noopener">snippet generator</a>生成，简单方便，还可用于 sublime 和 atom，生成的代码直接粘贴到下图这里就行了<br><img src="http://q9j7cl8us.bkt.clouddn.com/img/Screen Shot 2020-04-28 at 10.36.10 PM.png?imageslim" style="zoom: 33%;" /><br>保存文件，然后随便去一个 cpp 文件敲一下快捷码然后按回车或者 tab 就可以自动生成了</p>
<p>vscode 的 snippets 还有更多的功能，不过上面的已经够用了，感兴趣的可以看这篇<a href="https://blog.csdn.net/maokelong95/article/details/54379046" target="_blank" rel="noopener">博客</a>。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>snippets</tag>
      </tags>
  </entry>
</search>
